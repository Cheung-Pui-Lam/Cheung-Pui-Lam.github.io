<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Promise中的关键问题</title>
      <link href="/2022/07/23/Promise%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/23/Promise%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-一个-Promise-指定多个成功-x2F-失败回调函数-都会调用吗"><a href="#1-一个-Promise-指定多个成功-x2F-失败回调函数-都会调用吗" class="headerlink" title="1.一个 Promise 指定多个成功&#x2F;失败回调函数, 都会调用吗?"></a>1.一个 Promise 指定多个成功&#x2F;失败回调函数, 都会调用吗?</h1><ul><li><strong>答案是肯定的,当 promise 改变为对应状态时都会调用</strong></li></ul><h1 id="2-改变-promise-状态和指定回调函数谁先谁后"><a href="#2-改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="2.改变 promise 状态和指定回调函数谁先谁后?"></a>2.改变 promise 状态和指定回调函数谁先谁后?</h1><ul><li><strong>(1)都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</strong></li><li><strong>(2)如何先改状态再指定回调?</strong><ul><li><strong>① 在执行器中直接调用 resolve()&#x2F;reject()</strong></li><li><strong>② 延迟更长时间才调用 then()</strong></li></ul></li><li><strong>(3)什么时候才能得到数据?</strong><ul><li><strong>① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</strong></li><li><strong>② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</strong></li></ul></li></ul><h1 id="3-Promise-then-返回的新-Promise-的结果状态由什么决定"><a href="#3-Promise-then-返回的新-Promise-的结果状态由什么决定" class="headerlink" title="3.Promise.then()返回的新 Promise 的结果状态由什么决定?"></a>3.Promise.then()返回的新 Promise 的结果状态由什么决定?</h1><ul><li><strong>(1)简单表达: 由 then()指定的回调函数执行的结果决定</strong></li><li><strong>(2)详细表达:</strong><ul><li><strong>① 如果抛出异常, 新 promise 变为rejected, reason 为抛出的异常</strong></li><li><strong>② 如果返回的是非 promise 的任意值, 新 promise 变为resolved, value 为返回的值</strong></li><li><strong>③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</strong></li></ul></li></ul><h1 id="4-Promise中的异常穿透特性"><a href="#4-Promise中的异常穿透特性" class="headerlink" title="4.Promise中的异常穿透特性"></a>4.Promise中的异常穿透特性</h1><ul><li><strong>(1)当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</strong></li><li><strong>(2)前面任何操作出了异常, 都会传到最后失败的回调中处理</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">                <span class="comment">// reject(&#x27;Err&#x27;);</span></span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(111);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&#x27;失败啦!&#x27;</span>;</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);<span class="comment">//可以在最后的catch环节捕获第一层的错误</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/key-question/1.png" alt="image"></p><h3 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明:"></a>解释说明:</h3><ul><li><strong>promise的链式调用中存在一种异常穿透的特性,就是我们可以在链式作用的最后加上一个catch方法来捕获整个链式调用过程中的错误,无需在链式调用的每一个环节参加catch方法来捕获错误</strong></li></ul><h1 id="5-中断-Promise-的链式调用"><a href="#5-中断-Promise-的链式调用" class="headerlink" title="5.中断 Promise 的链式调用?"></a>5.中断 Promise 的链式调用?</h1><ul><li><strong>(1)当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</strong></li><li><strong>(2)办法: 在回调函数中返回一个 pendding 状态的 promise 对象</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">            <span class="comment">//有且只有一个方式:那就是返回一个pending状态的Promise对象,才能中断Promise1链条</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 输出结果只有111,无222,333</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="结果如下-1"><a href="#结果如下-1" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/key-question/2.png" alt="image"></p><h3 id="解释说明-1"><a href="#解释说明-1" class="headerlink" title="解释说明:"></a>解释说明:</h3><ul><li><strong>中断Promise链式调用的方法有且只有一种:那就是在你想要中断的环节当中添加一个pending状态的Promise对象返回值</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise中的常用API</title>
      <link href="/2022/07/23/Promise%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8API/"/>
      <url>/2022/07/23/Promise%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise中的常用API"><a href="#Promise中的常用API" class="headerlink" title="Promise中的常用API"></a><strong>Promise</strong>中的常用API</h1><h2 id="1-Promise中的构造函数-Promise-excutor"><a href="#1-Promise中的构造函数-Promise-excutor" class="headerlink" title="1.Promise中的构造函数 : Promise (excutor) {}"></a>1.Promise中的构造函数 : Promise (excutor) {}</h2><ul><li><strong>(1)executor 函数:执行器 (resolve, reject) &#x3D;&gt; {}</strong></li><li><strong>(2)resolve 函数: 内部定义成功时我们调用的函数 value &#x3D;&gt; {}</strong></li><li><strong>(3)reject 函数: 内部定义失败时我们调用的函数 reason &#x3D;&gt; {}</strong></li></ul><p> <strong>说明:</strong> executor 会在 Promise 内部<strong>立即同步调用</strong>,异步操作在执行器中执行</p><h4 id="函数解析"><a href="#函数解析" class="headerlink" title="函数解析:"></a>函数解析:</h4><p>我们可以通过 new Promise 来实例化对象,在new的时候,实例化需要接收一个参数,这个参数是一个函数类型的参数(可为箭头函数,也可为匿名函数),这个函数当中有两个形参:<strong>resolve</strong> 和 <strong>reject</strong> ,这两个形参也是一个函数,是Promise内部定义的,当Promise内异步任务为成功是就调用resolve,失败则调用reject</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1) 创建 promise 对象(pending 状态), 指定执行器函数</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2) 在执行器函数中启动异步任务</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">            <span class="comment">// 3) 根据结果做不同处理</span></span><br><span class="line">            <span class="comment">// 3.1) 如果成功了, 调用 resolve(), 指定成功的 value, 变为 resolved 状态</span></span><br><span class="line">            <span class="keyword">if</span> (time%<span class="number">2</span>===<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="string">&#x27;成功的值 &#x27;</span>+ time)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3.2) 如果失败了, 调用 reject(), 指定失败的 reason, 变为rejected 状态</span></span><br><span class="line">                    <span class="title function_">reject</span>(<span class="string">&#x27;失败的值&#x27;</span> + time)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-Promise-prototype-then-方法-onResolved-onRejected-x3D-gt"><a href="#2-Promise-prototype-then-方法-onResolved-onRejected-x3D-gt" class="headerlink" title="2.Promise.prototype.then 方法: (onResolved, onRejected) &#x3D;&gt; {}"></a>2.Promise.prototype.then 方法: (onResolved, onRejected) &#x3D;&gt; {}</h2><ul><li><strong>(1)onResolved 函数: 成功的回调函数 (value) &#x3D;&gt; {}</strong></li><li><strong>(2)onRejected 函数: 失败的回调函数 (reason) &#x3D;&gt; {}</strong><br><strong>说明:</strong> 指定用于得到<strong>成功 value 的成功回调</strong>和用于得到<strong>失败 reason 的失败回调</strong>返回一个<strong>新的 promise 对象</strong></li></ul><h4 id="函数解析-1"><a href="#函数解析-1" class="headerlink" title="函数解析:"></a>函数解析:</h4><p>then方法是用来指定回调的,里面传递<strong>两个函数类型(一般用箭头函数形式)的参数</strong>(onResolved,onRejected),<strong>成功执行第一个(onResolved)函数,失败执行第二个函数(onRejected)</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//能 promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason </span></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// 成功的回调函数 onResolved, 得到成功的 vlaue </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的 value: &#x27;</span>, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="comment">// 失败的回调函数 onRejected, 得到失败的 reason </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的 reason: &#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="3-Promise-prototype-catch-方法-onRejected-x3D-gt"><a href="#3-Promise-prototype-catch-方法-onRejected-x3D-gt" class="headerlink" title="3.Promise.prototype.catch 方法: (onRejected) &#x3D;&gt; {}"></a>3.Promise.prototype.catch 方法: (onRejected) &#x3D;&gt; {}</h2><ul><li><strong>用法与then想象,但是它只能用于指定失败的回调函数,不能用于指定成功的回调函数</strong><br> <strong>说明:</strong> then()的语法糖,  相当于: <strong>then(undefined, onRejected)</strong></li></ul><h4 id="函数解析-2"><a href="#函数解析-2" class="headerlink" title="函数解析:"></a>函数解析:</h4><p> <strong>catch</strong>方法其实就是用<strong>then</strong>做的一个单独独立的封装,它内部的实现原理就是用<strong>then方法</strong>单独指向<strong>reject状态</strong>而已<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//修改 promise 对象的状态</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行 catch 方法</span></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/API/1.png" alt="image"></p><h2 id="4-Promise-resolve-方法-value-x3D-gt"><a href="#4-Promise-resolve-方法-value-x3D-gt" class="headerlink" title="4.Promise.resolve 方法: (value) &#x3D;&gt; {}"></a>4.Promise.resolve 方法: (value) &#x3D;&gt; {}</h2><ul><li><strong>(1)value: 成功的数据或 promise 对象</strong><br> <strong>说明:</strong> 返回一个成功&#x2F;失败的 <strong>promise 对象</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.传入非Promise类型对象,返回必然成功Promise对象</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="comment">//2.如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果</span></span><br><span class="line">    <span class="comment">// 1).传入为reject类型的promise对象</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;OK&#x27;);</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line">    <span class="comment">// 2).传入为resolve类型的promise对象</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    <span class="comment">// reject(&#x27;Error&#x27;);</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);<span class="comment">//结果为:Promise &#123;&lt;fulfilled&gt;: &#x27;hello&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//结果为:Promise &#123;&lt;rejected&gt;: &#x27;Error&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);<span class="comment">//结果为:Promise &#123;&lt;fulfilled&gt;: &#x27;OK&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数解析-3"><a href="#函数解析-3" class="headerlink" title="函数解析:"></a>函数解析:</h4><p>相较于then和catch来说它有些不一样,resolve是属于Promise这个函数对象的,并不属于实例对象,作用是接收一个参数,返回一个成功或失败的Promise对象,其实它就是为了能够快速获得一个对象并且能够封装一个值,将这个值转化为一个Promise对象.</p><ul><li>如若传入的参数为 <strong>非Promise类型的对象</strong> ,<strong>返回的结果必然为成功的Peomise对象</strong>,返回值为你<strong>resolve()括号中的数值</strong></li><li>如若传入的参数为 <strong>Promise类型的对象</strong>,<strong>返回的结果则根据你传入的Promise的结果,如果你传入的是reject类型的Promise,这返回的就是reject,返回值为你reject()括号内的值,若为resolve也是类似</strong></li></ul><h4 id="结果如下-1"><a href="#结果如下-1" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/API/2.png" alt="image"></p><h2 id="5-Promise-reject-方法-reason-x3D-gt"><a href="#5-Promise-reject-方法-reason-x3D-gt" class="headerlink" title="5.Promise.reject 方法: (reason) &#x3D;&gt; {}"></a>5.Promise.reject 方法: (reason) &#x3D;&gt; {}</h2><ul><li><strong>(1)reason: 失败的原因</strong><br> <strong>说明:</strong> 只返回一个失败的 <strong>promise 对象</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);<span class="comment">//结果为:Promise &#123;&lt;rejected&gt;: &#x27;hello!&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);<span class="comment">//结果为:Promise &#123;&lt;rejected&gt;: Promise&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//结果为:Promise &#123;&lt;rejected&gt;: Promise&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数解析-4"><a href="#函数解析-4" class="headerlink" title="函数解析:"></a>函数解析:</h4><p>与resolve一样均是属于Promise这个函数对象的,并不属于实例对象,作用是接收一个参数,返回一个必然失败的Promise对象,其实它就是为了能够快速获得一个失败对象,将这个值转化为一个Promise对象.</p><ul><li>如若传入的参数为 <strong>非Promise类型的对象</strong> ,<strong>返回的结果必然为失败的Peomise对象</strong>,返回值为你<strong>reject()括号中的数值</strong></li><li>如若传入的参数为 <strong>Promise类型的对象</strong>,<strong>同返回一个必然失败的Promise对象,即便你传入的是resolve的Promise对象,返回的还是失败的Promise对象,但是返回的值就不是resolve()括号里面的值了,而是整一个对象,就是如果你给reject()里面传入一个resolve类型的Promise对象,返回的是一个失败的对象,返回值是整一个你传入的resolve类型Promise对象(即你传入什么Promise对象,就返回什么Promise对象)</strong></li></ul><h4 id="结果如下-2"><a href="#结果如下-2" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/API/3.png" alt="image"></p><h2 id="6-Promise-all-方法-promises-x3D-gt"><a href="#6-Promise-all-方法-promises-x3D-gt" class="headerlink" title="6.Promise.all 方法: (promises) &#x3D;&gt; {}"></a>6.Promise.all 方法: (promises) &#x3D;&gt; {}</h2><ul><li><strong>(1)promises: 包含 n 个 promise 的数组</strong><br> <strong>说明:</strong> 返回一个<strong>新的 promise</strong>, 只有<strong>所有</strong>的 promise 都成功才成功, <strong>只要有一个失败了就直接失败(相当于我们”与”,全真为真,一个假则为假)</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);<span class="comment">//全为成功,返回为fulfilled</span></span><br><span class="line"><span class="keyword">const</span> r2 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p4]);<span class="comment">//有一个失败,返回rejecte</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1);<span class="comment">//resolved</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2);<span class="comment">//rejected</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数解析-5"><a href="#函数解析-5" class="headerlink" title="函数解析:"></a>函数解析:</h4><p><strong>该方法返回的Promise对象由数组中的成员决定,如果数组成员全为resolve,则返回的Promise对象为resolve,返回结果为每一个成员的返回值组成的数组,若有一个失败,则返回的Promise对象为reject,返回的结果为该reject类型Promise对象的返回值</strong></p><h4 id="结果如下-3"><a href="#结果如下-3" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/API/4.png" alt="image"></p><h2 id="7-Promise-race-方法-promises-x3D-gt"><a href="#7-Promise-race-方法-promises-x3D-gt" class="headerlink" title="7.Promise.race 方法: (promises) &#x3D;&gt; {}"></a>7.Promise.race 方法: (promises) &#x3D;&gt; {}</h2><ul><li><strong>(1)value: 成功的数据或 promise 对象</strong><br> <strong>说明:</strong> 返回一个<strong>新的 promise</strong>, <strong>第一个完成</strong>的 promise 的结果状态就是最终的结果状态(<strong>相当于数组成员之间进行赛跑,设第一个转变状态,就返回谁</strong>)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里设置一个定时器,故意调慢p1</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>)</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);<span class="comment">//返回结果:fulfilled Success</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数解析-6"><a href="#函数解析-6" class="headerlink" title="函数解析:"></a>函数解析:</h4><p>race的本身意思就是赛跑的意思,race()方法本身接受一个参数,这个参数一般也是由一个Promise组成的数组,返回结果也是一个Promise1对象,与all有点相像,返回结果的状态由数组成员中第一个改变状态的Promise成员决定,返回结果的状态与之保持一致</p><h4 id="结果如下-4"><a href="#结果如下-4" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/API/5.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise的介绍</title>
      <link href="/2022/07/23/Promise%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/07/23/Promise%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Promise-是什么"><a href="#1-Promise-是什么" class="headerlink" title="1.Promise 是什么?"></a>1.<strong>Promise</strong> 是什么?</h1><ul><li><strong>1.抽象表达:</strong><ul><li>1)Promise 是一门新的技术(ES6 规范)</li><li>2)Promise 是 JS 中进行异步编程的新解决方案备注：旧方案是单纯使用回调函数（解决回调地狱）</li></ul></li><li><strong>2.具体表达:</strong><ul><li>1)从语法上来说: Promise 是一个构造函数</li><li>2)从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功&#x2F; 失败的结果值</li></ul></li></ul><h1 id="2-promise-的状态改变"><a href="#2-promise-的状态改变" class="headerlink" title="2.promise 的状态改变"></a>2.<strong>promise</strong> 的状态改变</h1><h2 id="一般有三种"><a href="#一般有三种" class="headerlink" title="一般有三种"></a>一般有三种</h2><ul><li><strong>pending</strong>: 它的意思是 “待定的，将发生的”，相当于是一个初始状态。创建Promise对象时，且没有调用resolve或者是reject方法，相当于是初始状态。这个初始状态会随着你调用resolve，或者是reject函数而切换到另一种状态。<br>   <img src="/../upload/promise/introduce/1.png" alt="image"></li><li><strong>reslove</strong>: 也叫<strong>fulfiller</strong>表示解决了，就是说这个承诺实现了。 要实现从pending到resolved的转变，需要在 创建Promise对象时，在函数体中调用了resolve方法(即第一个参数)。<br>   <img src="/../upload/promise/introduce/2.png" alt="image"></li><li><strong>rejected</strong>: 拒绝，失败。表示这个承诺没有做到，失败了。要实现从pending到rejected的转换，只需要在创建Promise对象时，调用reject函数。<br>   <img src="/../upload/promise/introduce/3.png" alt="image"></li></ul><h3 id="状态之间是可以相互转换的-但是这个过程是不可逆的"><a href="#状态之间是可以相互转换的-但是这个过程是不可逆的" class="headerlink" title="状态之间是可以相互转换的,但是这个过程是不可逆的"></a>状态之间是可以相互转换的,但是这个过程是不可逆的</h3><ul><li>1.pending 变为 resolved</li><li>2.pending 变为 rejected</li></ul><h3 id="说明-只有这-2-种-且一个-promise-对象只能改变一次无论变为成功还是失败-都会有一个结果数据-在then方法里面接收-成功的结果数据一般称为-value-失败的结果数据一般称为-reason"><a href="#说明-只有这-2-种-且一个-promise-对象只能改变一次无论变为成功还是失败-都会有一个结果数据-在then方法里面接收-成功的结果数据一般称为-value-失败的结果数据一般称为-reason" class="headerlink" title="说明: 只有这 2 种, 且一个 promise 对象只能改变一次无论变为成功还是失败, 都会有一个结果数据,在then方法里面接收,成功的结果数据一般称为 value, 失败的结果数据一般称为 reason"></a>说明: 只有这 2 种, 且一个 promise 对象只能改变一次无论变为成功还是失败, 都会有一个结果数据,在then方法里面接收,成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</h3><h1 id="3-promise-的基本流程"><a href="#3-promise-的基本流程" class="headerlink" title="3.promise 的基本流程"></a>3.promise 的基本流程</h1><p><img src="/../upload/promise/introduce/4.png" alt="image"></p><h1 id="4-promise-的基本使用"><a href="#4-promise-的基本使用" class="headerlink" title="4.promise 的基本使用"></a>4.promise 的基本使用</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1) 创建 promise 对象(pending 状态), 指定执行器函数</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2) 在执行器函数中启动异步任务</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">            <span class="comment">// 3) 根据结果做不同处理</span></span><br><span class="line">            <span class="comment">// 3.1) 如果成功了, 调用 resolve(), 指定成功的 value, 变为 resolved 状态</span></span><br><span class="line">            <span class="keyword">if</span> (time%<span class="number">2</span>===<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="string">&#x27;成功的值 &#x27;</span>+ time)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3.2) 如果失败了, 调用 reject(), 指定失败的 reason, 变为rejected 状态</span></span><br><span class="line">                    <span class="title function_">reject</span>(<span class="string">&#x27;失败的值&#x27;</span> + time)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4) 能 promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason </span></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// 成功的回调函数 onResolved, 得到成功的 vlaue </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的 value: &#x27;</span>, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="comment">// 失败的回调函数 onRejected, 得到失败的 reason </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的 reason: &#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Es6中的类与对象</title>
      <link href="/2022/07/20/Es6%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/07/20/Es6%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Es6中的类和对象"><a href="#Es6中的类和对象" class="headerlink" title="Es6中的类和对象"></a>Es6中的类和对象</h1><ul><li><p>相较于<strong>面向过程</strong>,<strong>面向对象</strong>更加贴近与我们的实际生活，可以使用<strong>面向对象</strong>来描述现实世界，但事物都分为具体事物和抽象事物。</p><ul><li>如一个手机就是一个抽象的事物(泛指的)</li><li>但是一台苹果X就是一个具体的事物(特指的)</li></ul></li><li><h3 id="面向对象的思维特点"><a href="#面向对象的思维特点" class="headerlink" title="面向对象的思维特点:"></a>面向对象的思维特点:</h3><ul><li><strong>1.抽取(抽象)对象的共用属性和行为方法组织(封装)成一个 类(模板)</strong><ul><li><strong>就像是每一台手机都能打电话,又有手机屏幕,都有电池,都有一个价格等…这就是手机的共同属性</strong></li></ul></li><li><strong>对 类 进行实例化,获取类的对象,如我们可以封装一个手机的 类 ,里面有名字,品牌,价格等属性,当我们调用这个 手机类 的时候,给他们赋予不一样的属性值就能产出 不同的手机,如我们给这个手机类的名字属性赋予:小米10, 品牌属性赋予:小米,那么再实例化这个类就能产出一台小米10的手机了</strong></li></ul><h4 id="所以面向对象编程考虑的就是有哪些对象-按照这些对象的思维特点-抽取它们的共同属性或方法-对象不断的创建出带有共同属性或者方法的对象-使用它们-指挥他们做事情"><a href="#所以面向对象编程考虑的就是有哪些对象-按照这些对象的思维特点-抽取它们的共同属性或方法-对象不断的创建出带有共同属性或者方法的对象-使用它们-指挥他们做事情" class="headerlink" title="所以面向对象编程考虑的就是有哪些对象,按照这些对象的思维特点,抽取它们的共同属性或方法,对象不断的创建出带有共同属性或者方法的对象,使用它们,指挥他们做事情"></a>所以面向对象编程考虑的就是有哪些对象,按照这些对象的思维特点,抽取它们的共同属性或方法,对象不断的创建出带有共同属性或者方法的对象,使用它们,指挥他们做事情</h4></li></ul><h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象?"></a>什么是对象?</h2><ul><li>在现实生活中,万物皆对象,对象是一个具体的事物,比如一辆车,一本书,一个人等…</li><li>在 JavaScript 中，对象是一组无序的<strong>相关属性和方法的集合</strong>，所有的事物都是对象，例如字符串、数值、数组、函数等。</li></ul><h3 id="对象是由属性和方法组成的："><a href="#对象是由属性和方法组成的：" class="headerlink" title="对象是由属性和方法组成的："></a>对象是由属性和方法组成的：</h3><ul><li><strong>属性：事物的特征，在对象中用属性来表示（常用名词）</strong></li><li><strong>方法：事物的行为，在对象中用方法来表示（常用动词）</strong></li></ul><h2 id="什么是-类-class"><a href="#什么是-类-class" class="headerlink" title="什么是 类 class ?"></a>什么是 类 class ?</h2><ul><li><strong>在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。</strong></li><li><strong>类抽象了对象的公共部分，它泛指某一大类（class）</strong></li><li><strong>对象特指某一个，通过类实例化一个具体的对象</strong><br>  <img src="/../upload/Es6/class/1.png" alt="image"></li><li><strong>上图中的设计图纸就是一个类,那辆车就是通过这个类实例化的对象</strong></li></ul><h1 id="重头戏-创建和使用-类"><a href="#重头戏-创建和使用-类" class="headerlink" title="重头戏:创建和使用 类"></a>重头戏:创建和使用 类</h1><ul><li><strong>注意： 类必须使用 new 实例化对象，方法之间不能加逗号分隔，同时方法不需要添加 function 关键字。</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建类 class</span><br><span class="line">        class Star&#123;</span><br><span class="line">            constructor(name , age)&#123;</span><br><span class="line">                this.name = name;</span><br><span class="line">                this.age = age;</span><br><span class="line">            &#125;</span><br><span class="line">            // 我们类里面所有的函数不需要写function ,页不需要用&quot;,&quot;分割</span><br><span class="line">            sing(song)&#123;</span><br><span class="line">                console.log(this.name + &#x27;唱的是&#x27; + song);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 使用类 new(实例化对象)</span><br><span class="line">        var ldh = new Star(&#x27;刘德华&#x27;,&#x27;20&#x27;);</span><br><span class="line">        // 执行过程如下：</span><br><span class="line">        // 1.你用 new 实例化对象，类就自动的调用 constructor 然后&#x27;刘德华&#x27;就会传递给constructor的形参 name ,name又赋值给this.name,而这个this是指向你创建的实例的,做因实例化对象内部就生成了一个 name : &#x27;刘德华&#x27; 属性</span><br><span class="line">        var zxy = new Star(&#x27;张学友&#x27;,&#x27;20&#x27;);</span><br><span class="line">        console.log(ldh);</span><br><span class="line">        console.log(zxy);</span><br><span class="line">        ldh.sing(&#x27;开心马骝&#x27;);</span><br><span class="line">        zxy.sing(&#x27;饿狼传说&#x27;)</span><br><span class="line"></span><br><span class="line">        //(1) 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</span><br><span class="line">        //(2) 类里面有个constructor 函数,可以接受传递过来的参数,同时自动返回实例对象,所以不需要调用return</span><br><span class="line">        //(3) constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数</span><br><span class="line">        //(4) 生成实例 new 不能省略</span><br><span class="line">        //(5) 最后注意语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function</span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>  <img src="/../upload/Es6/class/2.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Es6 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown的常用语法</title>
      <link href="/2022/07/20/MarkDown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/07/20/MarkDown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-标题的几种写法"><a href="#1-标题的几种写法" class="headerlink" title="1.标题的几种写法"></a>1.标题的几种写法</h1><h2 id="1-第一种-标题前面-“-”"><a href="#1-第一种-标题前面-“-”" class="headerlink" title="1)第一种(标题前面 + “#”)"></a>1)第一种(标题前面 + “#”)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#一级标题</span><br><span class="line">##二级标题</span><br><span class="line">###三级标题</span><br><span class="line">####四级标题</span><br><span class="line">#####五级标题</span><br><span class="line">######六级标题</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/1.png" alt="image"></p><ul><li><strong>前面带#号，后面带文字，分别表示h1-h6,上图可以看出，只到h6，而且h1下面会有一条横线，注意，#号后面有空格</strong></li></ul><h2 id="2-第二种-标题下面-“-x3D-x3D-x3D-”或者”—“"><a href="#2-第二种-标题下面-“-x3D-x3D-x3D-”或者”—“" class="headerlink" title="2)第二种(标题下面 + “&#x3D;&#x3D;&#x3D;”或者”—“)"></a>2)第二种(标题下面 + “&#x3D;&#x3D;&#x3D;”或者”—“)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">================</span><br><span class="line">二级标题</span><br><span class="line">---------------</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/2.png" alt="image"></p><ul><li><strong>这种方式好像只能表示一级和二级标题，而且&#x3D;和-的数量没有限制，只要大于一个就行</strong></li></ul><h2 id="3-第三种-标题前后都-“-”"><a href="#3-第三种-标题前后都-“-”" class="headerlink" title="3)第三种(标题前后都 + “#”)"></a>3)第三种(标题前后都 + “#”)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题 #</span><br><span class="line">## 二级标题 ##</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/3.png" alt="image"></p><ul><li><strong>这里的标题支持h1-h6，为了减少篇幅，我就偷个懒，只写前面二个，这个比较好理解，相当于标签闭合，注意，标题与#号要有空格</strong></li><li><strong>那既然3种都可以使用，可不可以混合使用呢？我试了一下，是可以的，但是为了让页面标签的统一性，不建议混合使用，推荐使用第一种，比较简洁，全面</strong></li></ul><h1 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h1><ul><li><strong>我们都知道，列表分为有序列表和无序列表，下面直接展示2种列表的写法：</strong></li></ul><h2 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 列表1</span><br><span class="line">+ 列表2</span><br><span class="line">- 列表3</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/4.png" alt="image"></p><ul><li><strong>可以看到，无序列表可以用* ， + ， — 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧</strong></li></ul><h2 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 有序列表</span><br><span class="line">1. 列表1</span><br><span class="line">2. 列表2</span><br><span class="line">3. 列表3</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/5.png" alt="image"></p><ul><li><strong>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的!</strong></li></ul><h3 id="比如"><a href="#比如" class="headerlink" title="比如:"></a>比如:</h3><p>  <img src="/../upload/markdown/6.png" alt="image"> <img src="/../upload/markdown/7.png" alt="image"></p><ul><li><strong>序号是乱的 3 9 1， 但是还是显示 3 4 5 ，这点必须注意了</strong></li></ul><h1 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3.区块引用"></a>3.区块引用</h1><ul><li><strong>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句</strong>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 不以结婚为目的的谈恋爱都是耍流氓</span><br><span class="line">    &gt;这是毛主席说的</span><br><span class="line">- 前方高能</span><br><span class="line">    &gt; 注意:这里是为了提醒前面有很刺激的事情发生,请做好准备</span><br></pre></td></tr></table></figure>  <img src="/../upload/markdown/8.png" alt="image"></li><li><strong>无序列表下方的便是引用，可以有多种用途，看你的需求了，用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格.</strong></li><li><strong>引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等</strong></li></ul><h3 id="另外-引用里面还可以继续套引用"><a href="#另外-引用里面还可以继续套引用" class="headerlink" title="另外 引用里面还可以继续套引用"></a>另外 引用里面还可以继续套引用</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;一级以用</span><br><span class="line">&gt;&gt;二级引用</span><br><span class="line">&gt;&gt;&gt;三级以用</span><br><span class="line">&gt;&gt;&gt;&gt;四级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;五级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;六级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;七级引用</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/9.png" alt="image"></p><h1 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h1><ul><li><em><em>分割线可以由</em> - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</em>*  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">********</span><br><span class="line">--------</span><br><span class="line">- - - - </span><br><span class="line">* * *</span><br><span class="line">----------</span><br><span class="line">- - - - </span><br></pre></td></tr></table></figure>  <img src="/../upload/markdown/10.png" alt="image"></li><li><strong>为了代码的排版好看，可以自己定规则，前面有用到星号，建议用减号</strong></li></ul><h1 id="5-链接"><a href="#5-链接" class="headerlink" title="5.链接"></a>5.链接</h1><ul><li><strong>支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。</strong></li></ul><h2 id="1-行内式"><a href="#1-行内式" class="headerlink" title="1).行内式"></a>1).行内式</h2>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 行内式</span><br><span class="line">[妙语连珠](http://www.abcd.com) 是什么意思</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/11.png" alt="image"></p><ul><li><strong>上图可知，行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中</strong></li></ul><h2 id="2-参数式"><a href="#2-参数式" class="headerlink" title="2).参数式"></a>2).参数式</h2>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 参数</span><br><span class="line">[name](http://www.abcd.com) &quot;名称&quot;</span><br><span class="line">[home](http://www.abcd.com) &quot;首页&quot;</span><br><span class="line">[也支持中文](http://www.abcd.com) &quot;..&quot;</span><br><span class="line"></span><br><span class="line">这里是[name],这里是[home],这里页是[也支持中文]</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/12.png" alt="image"></p><ul><li><strong>这就好理解了，就是把链接当成参数，适合多出使用相同链接的场景，注意参数的对应关系</strong></li></ul><h1 id="6-图片"><a href="#6-图片" class="headerlink" title="6.图片"></a>6.图片</h1><ul><li><strong>图片也有2种方式：行内式和参数式</strong>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![image](../upload/markdown/12.png)</span><br><span class="line"> [博客园]:(../upload/markdown/12.png)</span><br><span class="line"> 参数式图片,这里是![博客园]</span><br></pre></td></tr></table></figure></li><li><strong>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的</strong></li></ul><h1 id="7-代码框-这个没啥好说的"><a href="#7-代码框-这个没啥好说的" class="headerlink" title="7.代码框(这个没啥好说的)"></a>7.代码框(这个没啥好说的)</h1>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般是用:</span><br><span class="line"> ```(键盘左上角,切记一定是3个)</span><br><span class="line">代码编写区域</span><br><span class="line"> ```(键盘左上角,切记一定是3个)</span><br></pre></td></tr></table></figure><h1 id="8-表格-比较麻烦"><a href="#8-表格-比较麻烦" class="headerlink" title="8.表格(比较麻烦)"></a>8.表格(比较麻烦)</h1>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 表格</span><br><span class="line">| name | age | sex |</span><br><span class="line">|:----:|:---:|:---:|</span><br><span class="line">| tony | 20  | 男  |</span><br><span class="line">| lucy | 18  | 女  |</span><br><span class="line"></span><br><span class="line">表头!  |  表头2</span><br><span class="line">------- | -----------</span><br><span class="line">Content Cell | Content Cell</span><br><span class="line">Content Cell | Content Cell</span><br><span class="line"></span><br><span class="line">学号 | 姓名 | 分数</span><br><span class="line">  -  |  -   |  -</span><br><span class="line">小明 | 男   | 75</span><br><span class="line">小红 | 女   | 79</span><br><span class="line">小陆 | 男   | 92</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/13.png" alt="image"></p><ul><li><strong>从这3种不同写法看，表格的格式不一定要对的非常齐，但是为了好看，对齐肯定是最好的，第一种的分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中，还是有点意思的，不过现实出来的结果是，表格外面并没有线框包起来，不知道别人的怎么弄的</strong></li></ul><h1 id="9-强调"><a href="#9-强调" class="headerlink" title="9.强调"></a>9.强调</h1>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 强调</span><br><span class="line">*字体倾斜*</span><br><span class="line">_字体倾斜_</span><br><span class="line">**字体加粗**</span><br><span class="line">__字体加粗__</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/14.png" alt="image"></p><ul><li><strong>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</strong></li></ul><h1 id="10-转义"><a href="#10-转义" class="headerlink" title="10.转义"></a>10.转义</h1>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 转义</span><br><span class="line">* \\</span><br><span class="line">* \`</span><br><span class="line">* \~</span><br><span class="line">* \*</span><br><span class="line">* \_</span><br><span class="line">* \-</span><br><span class="line">* \+</span><br><span class="line">* \.</span><br><span class="line">* \!</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/15.png" alt="image"></p><ul><li><strong>就不一一列举了，基本上跟js转义是一样的</strong></li></ul><h1 id="11-删除线"><a href="#11-删除线" class="headerlink" title="11.删除线"></a>11.删除线</h1>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 删除线</span><br><span class="line">~~请删掉我把~~</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/16.png" alt="image"></p><h2 id="以上便是编写md文档的常用语法了-感谢观看"><a href="#以上便是编写md文档的常用语法了-感谢观看" class="headerlink" title="以上便是编写md文档的常用语法了!感谢观看!!"></a>以上便是编写md文档的常用语法了!感谢观看!!</h2><blockquote><p>这篇博客引用了作者为”<strong>斧子兔</strong>“的文章<br>原文链接为:<a href="https://www.cnblogs.com/fuzitu/p/10471073.html">CSDN</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown的常用语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象和面向过程的编程思想对比</title>
      <link href="/2022/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="编程的两大思想"><a href="#编程的两大思想" class="headerlink" title="编程的两大思想"></a><strong>编程的两大思想</strong></h1><ul><li><strong>1.面向过程(Procedure-Oriented programming)<strong>：是一种</strong>以过程为中心</strong>的编程思想。这些都是以什么正在发生为主要目标进行编程，直白点说就是分析一个要求实现所需要的步骤，然后一步一步的将这些步骤实现，举个例子：将大象装进冰箱需要三步：打开冰箱——装进大象——关上冰箱。<br>  <img src="/../upload/pop-oop/1.png" alt="image"></li><li><strong>2.面向对象(Object-Oriented programming)<strong>：作为一种新的编程思想，其本质是将要求</strong>分解成一个个对象</strong>，<strong>给他们赋予一些独特的属性或者方法</strong>，然后对象之间相互合作实现要求。还是原来的那个例子，大象装进冰箱，用面向对象的编程思想的话就是这样解决的：<ul><li>封装两个<strong>对象</strong>：<ul><li><strong>大象对象</strong>：属性或方法：进入冰箱</li><li><strong>冰箱对象</strong>：属性或方法：打开冰箱，关闭冰箱</li></ul></li><li>最后调用这些对象的属性或者方法来解决问题<br>  <img src="/../upload/pop-oop/2.png" alt="image"></li></ul></li></ul><h2 id="面向对象的特性："><a href="#面向对象的特性：" class="headerlink" title="面向对象的特性："></a>面向对象的特性：</h2><h3 id="1、封装性-2、继承性-3、多态性"><a href="#1、封装性-2、继承性-3、多态性" class="headerlink" title="1、封装性  2、继承性  3、多态性"></a>1、封装性  2、继承性  3、多态性</h3><p>  <img src="/../upload/pop-oop/3.png" alt="image"></p><h2 id="面向过程编程思想的优点：-适用于简单的程序需求"><a href="#面向过程编程思想的优点：-适用于简单的程序需求" class="headerlink" title="面向过程编程思想的优点：(适用于简单的程序需求)"></a>面向过程编程思想的优点：(适用于简单的程序需求)</h2><ul><li><strong>性能比面面向对象高，适合与硬件紧密联系起来，例如单片机编程就经常使用面向过程编程。</strong></li></ul><h2 id="面向对象编程思想的优点：-适用于复杂，大型的项目需求"><a href="#面向对象编程思想的优点：-适用于复杂，大型的项目需求" class="headerlink" title="面向对象编程思想的优点：(适用于复杂，大型的项目需求)"></a>面向对象编程思想的优点：(适用于复杂，大型的项目需求)</h2><ul><li><strong>易于维护，易于复用，易于扩展，由于面向对象有封装性，继承性和多态性的特点，可以设计出低耦合的系统，是系统更加灵活，易于维护。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象和面向过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise解决回调地狱</title>
      <link href="/2022/07/19/Promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/"/>
      <url>/2022/07/19/Promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise解决回调地狱问题"><a href="#Promise解决回调地狱问题" class="headerlink" title="Promise解决回调地狱问题"></a><strong>Promise</strong>解决回调地狱问题</h1><h2 id="什么是Promise？"><a href="#什么是Promise？" class="headerlink" title="什么是Promise？"></a>什么是<strong>Promise</strong>？</h2><ul><li><strong>Promise</strong> 是<strong>ES6</strong> 引入的异步编程的新解决方案。语法上 <strong>Promise</strong> 是一个构造函数， 用来<strong>封装异步操作</strong>并可以获取其成功或失败的结果。</li></ul><h2 id="什么是回调地狱？"><a href="#什么是回调地狱？" class="headerlink" title="什么是回调地狱？"></a>什么是<strong>回调地狱</strong>？</h2><ul><li>所谓回调地狱就是在回调函数里面不断的嵌套回调函数，这样就会导致代码不断缩进，可读性就会变得非常的差。</li><li>比如我要执行1秒打印一个人的姓名：<br>  <img src="/../upload/promise/1.png" alt="image"></li></ul><h2 id="这里我们可以使用Promise来解决回调地狱的问题"><a href="#这里我们可以使用Promise来解决回调地狱的问题" class="headerlink" title="这里我们可以使用Promise来解决回调地狱的问题"></a>这里我们可以使用<strong>Promise</strong>来解决回调地狱的问题</h2><ul><li>因为<strong>Promise</strong>存在一种链式调用</li><li>我们可以调用<strong>Promise</strong>中的<strong>then</strong>方法构成<strong>链式调用</strong>，代码如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const p = new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        var s = &#x27;老一&#x27;;</span><br><span class="line">        reslove(s);</span><br><span class="line">    &#125; , 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var s = &#x27;老二&#x27;;</span><br><span class="line">            reslove(s);</span><br><span class="line">        &#125; , 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var s = &#x27;老三&#x27;;</span><br><span class="line">            reslove(s);</span><br><span class="line">        &#125; , 1000)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var s = &#x27;老四&#x27;;</span><br><span class="line">            reslove(s);</span><br><span class="line">        &#125; , 1000)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var s = &#x27;老五&#x27;;</span><br><span class="line">            reslove(s);</span><br><span class="line">        &#125; , 1000)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var s = &#x27;老六&#x27;;</span><br><span class="line">            reslove(s);</span><br><span class="line">        &#125; , 1000)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下:"></a>运行结果如下:</h2><p><img src="/../upload/promise/2.png" alt="image"></p><h3 id="输出结果是一致的，但是解决了回调地狱的问题"><a href="#输出结果是一致的，但是解决了回调地狱的问题" class="headerlink" title="输出结果是一致的，但是解决了回调地狱的问题"></a><strong>输出结果是一致的，但是解决了回调地狱的问题</strong></h3><h2 id="原理刨析-链式调用的原理"><a href="#原理刨析-链式调用的原理" class="headerlink" title="原理刨析:(链式调用的原理)"></a><strong>原理刨析:(链式调用的原理)</strong></h2><ul><li><strong>调用 then 方法 then方法的返回结果是 Promise 对象, 对象状态由回调函数的执行结果决定</strong><ul><li>1).非 promise 类型的属性, 状态为成功或者失败, 返回值就是return后面跟着的值</li><li>2).是 promise 类型的属性, 状态为成功或者失败, 返回值就是return后面跟着的新的promise对象的reslove()或者reject()</li></ul></li><li><strong>在我看来，之所以Promise能够解决回调地狱的问题主要归功于 then 方法，then方法里面有一个return属性，而这个return属性当返回的是一个Promise对象时，那么如果后面还有嵌套的.then的话，返回的Promise对象就直接对接后面的.then方法，相当于上层Promise对象返回的新Promise对象就继续对接后面的.then方法，以此类推来解决回调地狱。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git中常见的报错</title>
      <link href="/2022/07/18/git%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%A5%E9%94%99/"/>
      <url>/2022/07/18/git%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h2 id="Git常见错误1"><a href="#Git常见错误1" class="headerlink" title="Git常见错误1:"></a>Git常见错误1:</h2><ul><li><h3 id="在git-bash中输入指令-git-status查看本地库状态时报错"><a href="#在git-bash中输入指令-git-status查看本地库状态时报错" class="headerlink" title="在git bash中输入指令:git status查看本地库状态时报错:"></a>在git bash中输入指令:git status查看本地库状态时报错:</h3> <img src="/../upload/git/git-wrong/1.png" alt="image"></li><li><h3 id="原因"><a href="#原因" class="headerlink" title="原因 :"></a>原因 :</h3></li><li>这个错误说明了没有 .git这样的一个目录，所以只需要 git init一下，就可以解决了，然后再重新建立远程连接即可.</li></ul><h2 id="Git常见错误2"><a href="#Git常见错误2" class="headerlink" title="Git常见错误2:"></a>Git常见错误2:</h2><ul><li><h3 id="在git-bash中输入指令-git-status查看本地库状态时报错-1"><a href="#在git-bash中输入指令-git-status查看本地库状态时报错-1" class="headerlink" title="在git bash中输入指令:git status查看本地库状态时报错:"></a>在git bash中输入指令:git status查看本地库状态时报错:</h3> <img src="/../upload/git/git-wrong/2.png" alt="image"></li><li><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因 :"></a>原因 :</h3></li><li>原因是在 xxx&#x2F;文件夹下有隐藏文件，删除掉即可(因为这是我博客的文件夹,里面存在.git的吟唱文件,执行git init时添加的,用于初始化本地库的)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
            <tag> git中常用的报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git中常用的linux指令</title>
      <link href="/2022/07/18/git%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84linux%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/07/18/git%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84linux%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="git中常用的linux指令有如下几个"><a href="#git中常用的linux指令有如下几个" class="headerlink" title="git中常用的linux指令有如下几个"></a><strong>git中常用的linux指令有如下几个</strong></h1><ul><li><h3 id="1、cd-改变目录-进入指定文件夹-。"><a href="#1、cd-改变目录-进入指定文件夹-。" class="headerlink" title="1、cd : 改变目录(进入指定文件夹)。"></a>1、cd : 改变目录(进入指定文件夹)。</h3> <img src="/../upload/git/git-linux-command/1.png" alt="image"></li><li><h3 id="2、cd-回退到上一个目录，直接cd进入默认目录"><a href="#2、cd-回退到上一个目录，直接cd进入默认目录" class="headerlink" title="2、cd .. : 回退到上一个目录，直接cd进入默认目录"></a>2、cd .. : 回退到上一个目录，直接cd进入默认目录</h3></li><li><h3 id="3、cd-：返回最近访问目录"><a href="#3、cd-：返回最近访问目录" class="headerlink" title="3、cd -  ：返回最近访问目录"></a>3、cd -  ：返回最近访问目录</h3> <img src="/../upload/git/git-linux-command/2.png" alt="image"></li><li><h3 id="4、pwd-显示当前所在的目录路径"><a href="#4、pwd-显示当前所在的目录路径" class="headerlink" title="4、pwd : 显示当前所在的目录路径"></a>4、pwd : 显示当前所在的目录路径</h3> <img src="/../upload/git/git-linux-command/3.png" alt="image"></li><li><h3 id="5、ls-ll-都是列出当前目录中的所有文件，相较于ls，ll列出的内容更为详细（包括权限、所属用户和组、大小、时间、名称等）"><a href="#5、ls-ll-都是列出当前目录中的所有文件，相较于ls，ll列出的内容更为详细（包括权限、所属用户和组、大小、时间、名称等）" class="headerlink" title="5、ls(ll): 都是列出当前目录中的所有文件，相较于ls，ll列出的内容更为详细（包括权限、所属用户和组、大小、时间、名称等）"></a>5、ls(ll): 都是列出当前目录中的所有文件，相较于ls，ll列出的内容更为详细（包括权限、所属用户和组、大小、时间、名称等）</h3> <img src="/../upload/git/git-linux-command/4.png" alt="image"><br> <img src="/../upload/git/git-linux-command/5.png" alt="image"></li><li><h3 id="6、ls-a-显示该文件夹中的隐藏文件"><a href="#6、ls-a-显示该文件夹中的隐藏文件" class="headerlink" title="6、ls -a : 显示该文件夹中的隐藏文件"></a>6、ls -a : 显示该文件夹中的隐藏文件</h3></li><li><h3 id="7、ls-l-列出文件的详细信息。"><a href="#7、ls-l-列出文件的详细信息。" class="headerlink" title="7、ls -l : 列出文件的详细信息。"></a>7、ls -l : 列出文件的详细信息。</h3></li><li><h3 id="8、touch-新建一个文件-如-touch-index-js-就会在当前目录下新建一个index-js文件。"><a href="#8、touch-新建一个文件-如-touch-index-js-就会在当前目录下新建一个index-js文件。" class="headerlink" title="8、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。"></a>8、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</h3> <img src="/../upload/git/git-linux-command/6.png" alt="image"></li><li><h3 id="9、rm-删除一个文件-rm-index-js-就会把index-js文件删除。"><a href="#9、rm-删除一个文件-rm-index-js-就会把index-js文件删除。" class="headerlink" title="9、rm: 删除一个文件, rm index.js 就会把index.js文件删除。"></a>9、rm: 删除一个文件, rm index.js 就会把index.js文件删除。</h3> <img src="/../upload/git/git-linux-command/7.png" alt="image"></li><li><h3 id="10、mkdir-新建一个目录-就是新建一个文件夹"><a href="#10、mkdir-新建一个目录-就是新建一个文件夹" class="headerlink" title="10、mkdir: 新建一个目录,就是新建一个文件夹"></a>10、mkdir: 新建一个目录,就是新建一个文件夹</h3></li><li><h3 id="11、rm-r-删除一个文件夹-rm-r-src-删除src目录rm-rf-x2F-切勿在Linux中尝试！删除电-脑中全部文件！"><a href="#11、rm-r-删除一个文件夹-rm-r-src-删除src目录rm-rf-x2F-切勿在Linux中尝试！删除电-脑中全部文件！" class="headerlink" title="11、rm -r : 删除一个文件夹, rm -r src 删除src目录rm -rf &#x2F; 切勿在Linux中尝试！删除电## 脑中全部文件！"></a>11、rm -r : 删除一个文件夹, rm -r src 删除src目录rm -rf &#x2F; 切勿在Linux中尝试！删除电## 脑中全部文件！</h3></li><li><h3 id="12、mv-移动文件-mv-index-html-src-。index-html-是我们要移动的文件-src-是目标文件夹-当然-这样写-必须保证文件和目标文件夹在同一目录下。"><a href="#12、mv-移动文件-mv-index-html-src-。index-html-是我们要移动的文件-src-是目标文件夹-当然-这样写-必须保证文件和目标文件夹在同一目录下。" class="headerlink" title="12、mv : 移动文件, mv index.html src 。index.html 是我们要移动的文件, src 是目标文件夹## ,当然, 这样写,必须保证文件和目标文件夹在同一目录下。"></a>12、mv : 移动文件, mv index.html src 。index.html 是我们要移动的文件, src 是目标文件夹## ,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</h3></li><li><h3 id="13、reset-重新初始化终端-x2F-清屏。"><a href="#13、reset-重新初始化终端-x2F-清屏。" class="headerlink" title="13、reset : 重新初始化终端&#x2F;清屏。"></a>13、reset : 重新初始化终端&#x2F;清屏。</h3></li><li><h3 id="14、clear-清屏。"><a href="#14、clear-清屏。" class="headerlink" title="14、clear : 清屏。"></a>14、clear : 清屏。</h3></li><li><h3 id="15、history-查看命令历史。"><a href="#15、history-查看命令历史。" class="headerlink" title="15、history : 查看命令历史。"></a>15、history : 查看命令历史。</h3></li><li><h3 id="16、help-帮助。"><a href="#16、help-帮助。" class="headerlink" title="16、help : 帮助。"></a>16、help : 帮助。</h3></li><li><h3 id="17、exit-退出。"><a href="#17、exit-退出。" class="headerlink" title="17、exit : 退出。"></a>17、exit : 退出。</h3></li><li><h3 id="18、-表示注释"><a href="#18、-表示注释" class="headerlink" title="18、# : 表示注释"></a>18、# : 表示注释</h3></li><li><h3 id="19、cat-在控制台中显示文件的全部信息-即打开该文件"><a href="#19、cat-在控制台中显示文件的全部信息-即打开该文件" class="headerlink" title="19、cat : 在控制台中显示文件的全部信息,即打开该文件"></a>19、cat : 在控制台中显示文件的全部信息,即打开该文件</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
            <tag> git中常用的linux指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记(4)-git远程库操作</title>
      <link href="/2022/07/18/git%E8%BF%9C%E7%A8%8B%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/07/18/git%E8%BF%9C%E7%A8%8B%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="git远程库操作指令"><a href="#git远程库操作指令" class="headerlink" title="git远程库操作指令"></a><strong>git</strong>远程库操作指令</h1><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v                      查看当前所有远程地址别名</span><br><span class="line">git remote add 别名 远程地址        起别名</span><br><span class="line">git push 别名 分支                  推送本地分支上的内容到远程仓库</span><br><span class="line">git clone 远程地址                  将远程仓库的内容克隆到本地</span><br><span class="line">git pull 远程库地址别名 远程分支名   将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</span><br></pre></td></tr></table></figure></code></pre><ul><li><h3 id="1-创建远程仓库别名-实操"><a href="#1-创建远程仓库别名-实操" class="headerlink" title="1.创建远程仓库别名(实操)"></a>1.创建远程仓库别名(实操)</h3><ul><li><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v 查看当前所有远程地址别名</span><br><span class="line">git remote add 别名 远程地址</span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例"><a href="#实操案例" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command3/1.png" alt="image"></li><li><strong>这个地址在创建完远程仓库后生成的连接，如图所示红框中</strong><br><img src="/../upload/git/git-command3/2.png" alt="image"></li></ul></li><li><h3 id="2-推送本地分支到远程仓库-实操"><a href="#2-推送本地分支到远程仓库-实操" class="headerlink" title="2.推送本地分支到远程仓库(实操)"></a>2.推送本地分支到远程仓库(实操)</h3><ul><li><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push 别名 分支</span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例-1"><a href="#实操案例-1" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command3/3.png" alt="image"></li><li><strong>此时发现已将我们master 分支上的内容推送到GitHub 创建的远程仓库。</strong><br><img src="/../upload/git/git-command3/4.png" alt="image"></li></ul></li><li><h3 id="3-克隆远程仓库到本地-实操"><a href="#3-克隆远程仓库到本地-实操" class="headerlink" title="3.克隆远程仓库到本地(实操)"></a>3.克隆远程仓库到本地(实操)</h3><ul><li><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 远程地址</span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例-2"><a href="#实操案例-2" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command3/5.png" alt="image"></li><li><strong>克隆结果：1、拉取代码 2、初始化本地仓库 3、自动帮你创建别名(origin)</strong><br><img src="/../upload/git/git-command3/6.png" alt="image"><br><img src="/../upload/git/git-command3/7.png" alt="image"></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>你开始对本地代码动手编写之前，一个好习惯是先把本地代码更新一下，通过pull操作使本地库在开始动手之前的那一刻与远程库版本一致，再进行本地代码的撰写，这样写完以后才push到远程仓库。</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
            <tag> 远程库操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记(3)-git的常用指令(2)</title>
      <link href="/2022/07/18/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A42/"/>
      <url>/2022/07/18/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A42/</url>
      
        <content type="html"><![CDATA[<h1 id="git的分支操作"><a href="#git的分支操作" class="headerlink" title="git的分支操作"></a><strong>git</strong>的分支操作</h1><ul><li><h2 id="什么是分支"><a href="#什么是分支" class="headerlink" title="什么是分支"></a><strong>什么是分支</strong></h2><ul><li>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）<br> <img src="/../upload/git/git-command2/1.png" alt="image"></li><li>Hot-fix(热修),表示紧急处理当前的分支,feature表示分支版本的新增功能,后续可以与主分支合并成为新的版本。</li></ul><h2 id="分支的好处"><a href="#分支的好处" class="headerlink" title="分支的好处"></a><strong>分支的好处</strong></h2><ul><li>同时并行推进多个功能开发，提高开发效率。</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可</li></ul></li><li><h2 id="分支常用指令"><a href="#分支常用指令" class="headerlink" title="分支常用指令"></a><strong>分支常用指令</strong></h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch 分支名           创建分支</span><br><span class="line">git branch -v               查看分支</span><br><span class="line">git checkout 分支名         切换分支</span><br><span class="line">git merge 分支名            把指定的分支合并到当前分支上</span><br></pre></td></tr></table></figure></li><li><h3 id="1-查看分支-实操"><a href="#1-查看分支-实操" class="headerlink" title="1.查看分支(实操)"></a>1.查看分支(实操)</h3><ul><li><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -v </span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例"><a href="#实操案例" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command2/2.png" alt="image"></li></ul></li><li><h3 id="2-创建分支-实操"><a href="#2-创建分支-实操" class="headerlink" title="2.创建分支(实操)"></a>2.创建分支(实操)</h3><ul><li><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch 分支名 </span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例-1"><a href="#实操案例-1" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command2/3.png" alt="image"></li></ul></li><li><h3 id="3-修改分支-实操"><a href="#3-修改分支-实操" class="headerlink" title="3.修改分支(实操)"></a>3.修改分支(实操)</h3><ul><li><h4 id="实操案例-2"><a href="#实操案例-2" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command2/4.png" alt="image"><br><img src="/../upload/git/git-command2/5.png" alt="image"></li></ul></li><li><h3 id="4-切换分支-实操"><a href="#4-切换分支-实操" class="headerlink" title="4.切换分支(实操)"></a>4.切换分支(实操)</h3><ul><li><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例-3"><a href="#实操案例-3" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command2/6.png" alt="image"><br><img src="/../upload/git/git-command2/7.png" alt="image"></li></ul></li><li><h3 id="5-合并分支-实操"><a href="#5-合并分支-实操" class="headerlink" title="5.合并分支(实操)"></a>5.合并分支(实操)</h3><ul><li><h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例-4"><a href="#实操案例-4" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command2/8.png" alt="image"></li><li><h2 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a><strong>分支冲突</strong></h2><ul><li><h3 id="冲突产生的表现：后面状态为-MERGING-合并中"><a href="#冲突产生的表现：后面状态为-MERGING-合并中" class="headerlink" title="冲突产生的表现：后面状态为 MERGING(合并中)"></a><strong>冲突产生的表现：后面状态为 MERGING(合并中)</strong></h3>  <img src="/../upload/git/git-command2/9.png" alt="image"><br>  <img src="/../upload/git/git-command2/10.png" alt="image"></li><li><h3 id="冲突产生的原因："><a href="#冲突产生的原因：" class="headerlink" title="冲突产生的原因："></a><strong>冲突产生的原因：</strong></h3><ul><li>合并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。Git 无法替我们决定使用哪一个。必须<strong>人为决定</strong>新代码内容。</li><li><strong>查看状态（检测到有文件有两处修改）</strong><br>  <img src="/../upload/git/git-command2/11.png" alt="image"></li></ul></li><li><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a><strong>解决冲突</strong></h3><ul><li><h3 id="1）编辑有冲突的文件，删除特殊符号，决定要使用的内容"><a href="#1）编辑有冲突的文件，删除特殊符号，决定要使用的内容" class="headerlink" title="1）编辑有冲突的文件，删除特殊符号，决定要使用的内容"></a>1）编辑有冲突的文件，删除特殊符号，决定要使用的内容</h3>  <strong>特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;合并过来的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</strong><br>  <img src="/../upload/git/git-command2/12.png" alt="image"><br>  <img src="/../upload/git/git-command2/13.png" alt="image"></li><li><h3 id="2）添加到暂存区"><a href="#2）添加到暂存区" class="headerlink" title="2）添加到暂存区"></a>2）添加到暂存区</h3>  <img src="/../upload/git/git-command2/14.png" alt="image"></li><li><h3 id="3）执行提交（注意：此时使用-git-commit-命令时不能带文件名后缀名）"><a href="#3）执行提交（注意：此时使用-git-commit-命令时不能带文件名后缀名）" class="headerlink" title="3）执行提交（注意：此时使用 git commit 命令时不能带文件名后缀名）"></a>3）执行提交（注意：此时使用 git commit 命令时不能带文件名后缀名）</h3>  <img src="/../upload/git/git-command2/15.png" alt="image"></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
            <tag> git的常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记(2)-git的常用指令</title>
      <link href="/2022/07/17/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/07/17/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="git常用指令"><a href="#git常用指令" class="headerlink" title="git常用指令"></a><strong>git</strong>常用指令</h1><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name 用户名(自定义)       设置用户签名</span><br><span class="line">git config --global user.email 邮箱(可以是虚拟的)  设置用户签名</span><br><span class="line">git init                                          初始化本地库</span><br><span class="line">git status                                        查看本地库状态</span><br><span class="line">git add 文件名                                     添加到暂存区</span><br><span class="line">git rm --cached 文件名                            将指定文件从暂存区中删除,但保留工作区的文件</span><br><span class="line">git commit -m &quot;日志信息&quot; 文件名                    提交到本地库</span><br><span class="line">git reflog(也可简写为git log)                      查看历史记录</span><br><span class="line">git reset --hard 版本号                            版本穿梭</span><br></pre></td></tr></table></figure></code></pre><h2 id="1-设置用户签名-实操"><a href="#1-设置用户签名-实操" class="headerlink" title="1.设置用户签名(实操)"></a>1.设置用户签名(实操)</h2><ul><li><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name 用户名</span><br><span class="line">git config --global user.email 邮箱</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例"><a href="#实操案例" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/1.png" alt="image"></li><li><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3> 签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。<strong>注意:</strong> 这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</li></ul><h2 id="2-初始化本地库-实操"><a href="#2-初始化本地库-实操" class="headerlink" title="2.初始化本地库(实操)"></a>2.初始化本地库(实操)</h2><ul><li><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  init </span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-1"><a href="#实操案例-1" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/2.png" alt="image"></li><li><strong>结果查看</strong><br>  <img src="/../upload/git/git-command/3.png" alt="image"></li></ul><h2 id="3-查看本地库状态"><a href="#3-查看本地库状态" class="headerlink" title="3.查看本地库状态"></a>3.查看本地库状态</h2><ul><li><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status </span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-2"><a href="#实操案例-2" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/4.png" alt="image"></li><li><h3 id="新增文件-hello-txt"><a href="#新增文件-hello-txt" class="headerlink" title="新增文件(hello.txt)"></a><strong>新增文件(hello.txt)</strong></h3>  <img src="/../upload/git/git-command/5.png" alt="image"></li><li><h3 id="再次查看-检测到未追踪的文件即文件为红色表示未添加到暂存区"><a href="#再次查看-检测到未追踪的文件即文件为红色表示未添加到暂存区" class="headerlink" title="再次查看(检测到未追踪的文件即文件为红色表示未添加到暂存区)"></a><strong>再次查看(检测到未追踪的文件即文件为红色表示未添加到暂存区)</strong></h3>  <img src="/../upload/git/git-command/6.png" alt="image"></li></ul><h2 id="4-添加暂存区"><a href="#4-添加暂存区" class="headerlink" title="4.添加暂存区"></a>4.添加暂存区</h2><ul><li><h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add 文件名</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-3"><a href="#实操案例-3" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/7.png" alt="image"></li><li><h3 id="查看状态（检测到暂存区有新文件-文件变绿）"><a href="#查看状态（检测到暂存区有新文件-文件变绿）" class="headerlink" title="查看状态（检测到暂存区有新文件,文件变绿）"></a><strong>查看状态（检测到暂存区有新文件,文件变绿）</strong></h3> <img src="/../upload/git/git-command/8.png" alt="image"></li></ul><h2 id="5-提交本地库-将暂存区的文件提交到本地库"><a href="#5-提交本地库-将暂存区的文件提交到本地库" class="headerlink" title="5.提交本地库(将暂存区的文件提交到本地库)"></a>5.提交本地库(将暂存区的文件提交到本地库)</h2><ul><li><h3 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;日志信息&quot; 文件名</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-4"><a href="#实操案例-4" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/9.png" alt="image"></li><li><h3 id="查看状态（没有文件需要提交）"><a href="#查看状态（没有文件需要提交）" class="headerlink" title="查看状态（没有文件需要提交）"></a><strong>查看状态（没有文件需要提交）</strong></h3> <img src="/../upload/git/git-command/10.png" alt="image"></li></ul><h2 id="6修改文件（hello-txt）"><a href="#6修改文件（hello-txt）" class="headerlink" title="6修改文件（hello.txt）"></a>6修改文件（hello.txt）</h2><ul><li><h3 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim 文件名</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-5"><a href="#实操案例-5" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/11.png" alt="image"></li><li><h3 id="查看状态（检测到工作区有文件被修改）"><a href="#查看状态（检测到工作区有文件被修改）" class="headerlink" title="查看状态（检测到工作区有文件被修改）"></a><strong>查看状态（检测到工作区有文件被修改）</strong></h3> <img src="/../upload/git/git-command/12.png" alt="image"></li><li><h3 id="将修改的文件再次添加暂存区）"><a href="#将修改的文件再次添加暂存区）" class="headerlink" title="将修改的文件再次添加暂存区）"></a><strong>将修改的文件再次添加暂存区）</strong></h3> <img src="/../upload/git/git-command/13.png" alt="image"></li><li><h3 id="查看状态（工作区的修改添加到了暂存区）"><a href="#查看状态（工作区的修改添加到了暂存区）" class="headerlink" title="查看状态（工作区的修改添加到了暂存区）"></a><strong>查看状态（工作区的修改添加到了暂存区）</strong></h3> <img src="/../upload/git/git-command/14.png" alt="image"></li></ul><h2 id="7-查看历史版本"><a href="#7-查看历史版本" class="headerlink" title="7.查看历史版本"></a>7.查看历史版本</h2><ul><li><h3 id="基本语法-6"><a href="#基本语法-6" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog查看版本信息</span><br><span class="line">git log查看版本详细信息</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-6"><a href="#实操案例-6" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/15.png" alt="image"></li></ul><h2 id="8-版本穿梭"><a href="#8-版本穿梭" class="headerlink" title="8.版本穿梭"></a>8.版本穿梭</h2><ul><li><h3 id="基本语法-7"><a href="#基本语法-7" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-7"><a href="#实操案例-7" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/16.png" alt="image"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
            <tag> git的常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的学习笔记(1)</title>
      <link href="/2022/07/17/git%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/17/git%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="git的学习笔记（1）"><a href="#git的学习笔记（1）" class="headerlink" title="git的学习笔记（1）"></a><strong>git</strong>的学习笔记（1）</h1><h2 id="1-什么是git？"><a href="#1-什么是git？" class="headerlink" title="1.什么是git？"></a>1.什么是<strong>git</strong>？</h2><ul><li><strong>Git</strong>是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种项目。</li><li><strong>Git</strong>易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。</li></ul><h2 id="2-什么是版本控制工具-集中式和分布式"><a href="#2-什么是版本控制工具-集中式和分布式" class="headerlink" title="2.什么是版本控制工具(集中式和分布式)"></a>2.什么是版本控制工具(集中式和分布式)</h2><ul><li>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</li><li>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本， 方便版本切换。</li></ul><h4 id="1-集中式版本控制工具"><a href="#1-集中式版本控制工具" class="headerlink" title="1)集中式版本控制工具"></a>1)集中式版本控制工具</h4><ul><li><strong>集中化的版本控制系统</strong>诸如 CVS、SVN 等，<strong>都有一个单一的集中管理的服务器</strong>，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</li><li>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</li><li>事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。<br> <img src="/../upload/git/1.png" alt="image"></li></ul><h4 id="2-分布式版本控制工具"><a href="#2-分布式版本控制工具" class="headerlink" title="2)分布式版本控制工具"></a>2)分布式版本控制工具</h4><ul><li>像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</li></ul><h5 id="分布式的版本控制系统出现之后-解决了集中式版本控制系统的缺陷"><a href="#分布式的版本控制系统出现之后-解决了集中式版本控制系统的缺陷" class="headerlink" title="分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:"></a><strong>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:</strong></h5><ul><li>(1).服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li><li>(2).每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）<br> <img src="/../upload/git/2.png" alt="image"></li></ul><h2 id="3-工作机制"><a href="#3-工作机制" class="headerlink" title="3.工作机制"></a>3.工作机制</h2><h4 id="Git的分区包括工作区、暂存区、本地仓库（本地版本库）、远程仓库（远程版本库）。"><a href="#Git的分区包括工作区、暂存区、本地仓库（本地版本库）、远程仓库（远程版本库）。" class="headerlink" title="Git的分区包括工作区、暂存区、本地仓库（本地版本库）、远程仓库（远程版本库）。"></a>Git的分区包括工作区、暂存区、本地仓库（本地版本库）、远程仓库（远程版本库）。</h4><ul><li>1.<strong>工作区:</strong> 所谓工作区就是写代码的地方但并非开发工具（开发平台）代码存放的磁盘的目录的位置</li><li>2.<strong>暂存区:</strong> 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。工作区写好的代码需要让git追踪到，因此你需要将工作区的代码添加（git add）到暂存区,暂存区的代码是临时存储(没有生成历史版本),即暂存区和工作区的代码均可以被删除</li><li>3.<strong>本地库:</strong> 将暂存区的代码提交(git commit)到本地库就会生成对应的历史版本,即不可能删除掉了,除非你将整个本地库删除</li><li>4.<strong>远程库:</strong> 将本地库的代码推送(push)到远程库(github),可用于远程恢复代码,当我们的电脑磁盘损坏亦或者新版本代码错误过多时可以通过远程库进行版本的回退以及代码的回滚<ul><li><strong>远程库</strong>又称<strong>代码托管中心</strong>，是基于网络服务器的远程代码仓库<ul><li><strong>GitLab</strong>(基于局域网的代码托管中心)</li><li><strong>GitHub</strong>（外网）</li><li><strong>Gitee</strong> 码云（国内网站，相当于国内的github）<br><img src="/../upload/git/4.png" alt="image"></li></ul></li></ul></li></ul><h4 id="具体实现流程"><a href="#具体实现流程" class="headerlink" title="具体实现流程"></a>具体实现流程</h4><ul><li>假如要实现上传代码功能，工作区使用add添加文件到暂存区，暂存区再通过commit提交版本给本地仓库，最后本地仓库使用push将版本推送到远程仓库；</li><li>工作区修改的文件可以通过checkout命令从本地仓库或暂存区恢复；如果要将工作区某分支的代码更新为远程仓库最新版本，可以使用pull命令；</li><li>对远程仓库使用clone可以将远程仓库主分支拷贝到本地仓库，fetch命令与pull类似，只是pull会合并本地代码，而fetch只会把最新版本抓取到本地版本库，不考虑本地仓库是否有新增。</li></ul><blockquote><p>这类git博客主要引用了作者为”<strong>尚硅谷</strong>“的文章，是博主在学习尚硅谷的<strong>git</strong>教程做的一些笔记<br>这篇博客另外引用了作者为”<strong>luffylv</strong>“和”<strong>长期闲置</strong>“的文章<br>原文链接为:<a href="https://www.bilibili.com/video/BV1vy4y1s7k6?p=1&vd_source=eeca4958b140403ede65df6022e4b306">BiliBili</a>、<a href="https://blog.csdn.net/m0_47503416/article/details/110100690">CSDN</a>、<a href="https://www.php.cn/tool/git/490641.html">PHP中文网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改butterfly2</title>
      <link href="/2022/07/16/%E9%AD%94%E6%94%B9butterfly2/"/>
      <url>/2022/07/16/%E9%AD%94%E6%94%B9butterfly2/</url>
      
        <content type="html"><![CDATA[<h1 id="魔改butterfly主题2-插入自定义样式"><a href="#魔改butterfly主题2-插入自定义样式" class="headerlink" title="魔改butterfly主题2-插入自定义样式"></a>魔改butterfly主题2-插入自定义样式</h1><p><strong>在原来的butterfly主题上插入自己喜欢的样式获证更改原来的样式</strong></p><ul><li>Hexo主题给我们预备了一个自定义接口，路径在主题目录下的_config.yml里面你的Inject中，具体如下：<br><img src="/../upload/mogai2/1.png" alt="image"></li><li>我们只需要在主题目录下先建一个样式文件夹，在里面新建一个样式表（css文件）用于存放我们的自定义样式即可：<br><img src="/../upload/mogai2/2.png" alt="image"></li><li>这的Mycss里面的style.css就是我新建的样式表，随后我们在head里面的link标签中引入对应的路径即可，然后我们通过浏览器，动态捕获对应的标签类名，id名即可对对应的样式进行更改自定义：<br><img src="/../upload/mogai2/3.png" alt="image"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔改butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改butterfly1</title>
      <link href="/2022/07/16/%E9%AD%94%E6%94%B9butterfly1/"/>
      <url>/2022/07/16/%E9%AD%94%E6%94%B9butterfly1/</url>
      
        <content type="html"><![CDATA[<h1 id="魔改butterfly主题1-gallery图库"><a href="#魔改butterfly主题1-gallery图库" class="headerlink" title="魔改butterfly主题1-gallery图库"></a>魔改butterfly主题1-gallery图库</h1><p><strong>将原来的gallery图库魔改成自己喜欢功能的页面跳转（这里我将gallery图库改成了一个小游戏中心）</strong></p><ul><li><h2 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h2><ul><li><p>1、首先导入gallery图库:在主题目录下的_config.yml中的menu菜单中新建导航栏小游戏<br>  <img src="/../upload/mogai1/1.png" alt="image"></p></li><li><p>2、然后调用hexo指令(hexo new page 页面名字(这里是game))新建一个页面用于存放图库,然后在这个新页面中添加小游戏的&#x2F;game&#x2F;类型用于绑定页面<br>  <img src="/../upload/mogai1/2.png" alt="image"></p></li><li><p>3、随后就是固定搭配,将代码复制进入有也页面的md文件中即可,就像上图一样,代码格式如下:</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;gallery-group-main&quot;&gt;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- 1).name：图框上面的名字 2. description：图库描述  --&gt;</span><br><span class="line">&lt;!-- 3).link：连接到对应相册的地址  --&gt;</span><br><span class="line">&lt;!-- 4).img-url：图库封面的地址 --&gt;</span><br></pre></td></tr></table></figure><p>  <strong>完成后如下图所示:</strong><br>  <img src="/../upload/mogai1/3.png" alt="image"></p></li><li><p><strong>关键步骤:</strong></p><ul><li><p>1)点击跳转的实现:这里需要魔改源代码,Hexo好像内置了插件，默认 不同源才会新的链接打开。如果想以新链接形式打开，需要改下源码，找到 【node_modules\hexo-theme-butterfly\scripts\tag\gallery.js】，代码大概在27行左右，将 &lt; a href&#x3D;’ ‘&gt;&lt;&#x2F; a&gt; 改成 &lt; a href&#x3D;’${url}’ target&#x3D;”_blank”&gt;&lt;&#x2F; a&gt; ,这样点击相册就会跳转到一个新页面。</p></li><li><p>2)解决渲染问题，要想跳转的新页面没有主题嵌入的问题（主题嵌入：跳转新页面成功了，但是还是有原来的样式，就是你博客的原样式存在，并没有我小游戏的样式存在，就相当于点击跳转新页面（回到你新的博客页面），然后游戏嵌在了博客页面里面）图如下：<br>  <img src="/../upload/mogai1/4.png" alt="image"></p></li><li><p>3)解决方法：设置指向的页面跳过渲染即可（这里是游戏页面）<br>  具体实施步骤：<br>  找到根目录下的_config.yml里面的skip_render，像下面一样跳过渲染指定的文件夹即可。<br>  <img src="/../upload/mogai1/5.png" alt="image"><br>  然后再在git bash里面一键三连，记住一定要先执行清除命令：hexo cl</p><p>  <strong>Hexo的原文档如下：</strong></p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render: &quot;mypage/**/*&quot;</span><br><span class="line"># 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &#x27;public&#x27; 目录</span><br><span class="line"># 你也可以用这种方法来跳过对指定文章文件的渲染</span><br><span class="line">skip_render: &quot;_posts/test-post.md&quot;</span><br><span class="line"># 这将会忽略对 &#x27;test-post.md&#x27; 的渲染</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔改butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用指令</title>
      <link href="/2022/07/13/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/07/13/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo常用指令介绍"><a href="#hexo常用指令介绍" class="headerlink" title="hexo常用指令介绍"></a>hexo常用指令介绍</h1><ul><li><strong>$ hexo clean</strong> (清空)<ul><li>清除缓存文件 db.json 和已生成的静态文件 public 。</li><li>网站显示异常时可以执行这条命令试试。</li></ul></li><li><strong>$ hexo g</strong> (重新生成)<ul><li><p>生成网站静态文件到默认设置的 public 文件夹。</p></li><li><p>便于查看网站生成的静态文件或者手动部署网站；</p></li><li><p>如果使用自动部署，不需要先执行该命令；<br>  hexo g 是 hexo generate 的缩写，命令效果一致</p></li></ul></li><li><strong>$ hexo s</strong> (重新启动)<ul><li>启动本地服务器，用于预览主题。<br>   -hexo s 是 hexo server 的缩写，命令效果一致；</li><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果</li></ul></li><li><strong>$ hexo d</strong> (重新部署到仓库)<ul><li>自动生成网站静态文件，并部署到设定的仓库。</li><li>hexo d 是 hexo deploy 的缩写，命令效果一致</li></ul></li><li><strong>$ hexo new “文章标题”</strong>(新建文章)<ul><li>文章标题也可以在对应的md文件中修改</li></ul></li><li><strong>$ hexo new page 网页名</strong><ul><li>例：hexo new page welcome</li><li>新建一个标题名为welcome的页面，默认连接地址：主页地址&#x2F;welcome&#x2F;</li><li>此页面不会出现在首页文章列表和归档中，也不支持设置分类和标签</li></ul></li></ul><h2 id="更新博客"><a href="#更新博客" class="headerlink" title="更新博客"></a>更新博客</h2><ul><li>一般会打开博客所在文件夹内右键 Git Bash Here，然后再命令行一键三连： <figure class="highlight plaintext"><figcaption><span>Command(代码指令)</span></figcaption><table><tr><td class="code"><pre><span class="line">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li><li>然后我么就可以打开浏览器输入主机地址:localhost:4000&#x2F;，查看自己更新的博客了！</li><li>不过这只是在本地进行了更新，要想部署到网上（Github上），还要输入如下指令： <figure class="highlight plaintext"><figcaption><span>Command(代码指令)</span></figcaption><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li><li>这样就能自动生成网站静态文件，并部署到我们设定的github仓库上了,别人访问我们的网站也能看到我们更新的内容了。</li></ul><blockquote><p>这篇博客引用了作者为”<strong>到现在负</strong>“的文章<br>原文链接为:<a href="https://blog.csdn.net/dxxzst/article/details/76135935">CSDN</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello！欢迎来到我的仓库！</title>
      <link href="/2022/07/13/Hello-Blog/"/>
      <url>/2022/07/13/Hello-Blog/</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客，用来记录这个博客网站的诞生！<br>后续我将会在这个博客中记录自己的前端学习历程！</p><ul><li><ul><li><ul><li>该博客诞生于2022年7月13日</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博主个人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
