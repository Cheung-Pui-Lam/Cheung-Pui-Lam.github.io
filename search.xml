<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue学习笔记(1)-模板语法,数据绑定以及数据代理</title>
      <link href="/2022/08/01/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <url>/2022/08/01/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="1-模板语法"><a href="#1-模板语法" class="headerlink" title="1.模板语法"></a>1.模板语法</h1><h2 id="什么是模板"><a href="#什么是模板" class="headerlink" title="什么是模板?"></a>什么是模板?</h2><ul><li><strong>Root容器中的代码就被称为Vue的模板，每当我们引入Vue.js过后,全局就多了一个名为Vue的构造函数.</strong></li><li><strong>模板语法一般分为两种:</strong><ul><li><strong>1.插值语法(一定要切记,使用模板语法过后,语法包括的值就不再是字符串..他就是js表达式了)</strong><ul><li><strong>功能：用于解析标签体内容。(就是起始标签和结束标签包括的内容)</strong></li><li><strong>写法：，xxx是js表达式，且可以直接读取到data中的所有属性。</strong></li></ul></li><li><strong>2.指令语法</strong><ul><li><strong>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。</strong></li><li><strong>举例：v-bind:href&#x3D;”xxx” 或  简写为 :href&#x3D;”xxx”，xxx同样要写js表达式，且可以直接读取到data中的所有属性。</strong></li></ul></li><li><strong>备注:Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 准备好一个容器--&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>插值语法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>你好，&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--重点: 一旦使用了指令语法,那么后面的属性值就有字符串(数值)变成了js表达式 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>指令语法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 完整写法 此时这里的 school.url.toUpperCase() 就是js表达式 并非字符串 读取url变量--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;school.url.toUpperCase()&quot;</span> <span class="attr">x</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>点我去&#123;&#123;school.name&#125;&#125;学习1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 简洁写法(省略v-bind) --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;school.url&quot;</span> <span class="attr">x</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>点我去&#123;&#123;school.name&#125;&#125;学习2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span> <span class="comment">//阻止 vue 在启动时生成生产提示。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">name</span>:<span class="string">&#x27;zpl&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">school</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="attr">name</span>:<span class="string">&#x27;五邑大学&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="attr">url</span>:<span class="string">&#x27;https://www.wyu.edu.cn/&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/Vue/V1/1.png" alt="image"></p><h1 id="2-数据绑定"><a href="#2-数据绑定" class="headerlink" title="2.数据绑定"></a>2.数据绑定</h1><ul><li><strong>单向数据绑定: v-bind</strong><ul><li><strong>数据只能从data流向页面。</strong></li></ul></li><li><strong>双向数据绑定: v-model</strong><ul><li><strong>数据不仅能从data流向页面，还可以从页面流向data。</strong></li></ul></li><li><strong>备注:只能用于表单类元素(输入类元素,就是要有value值才行,类似h标签不适用)上,如input,select等…,v-model可以简化为:v-model,因为v-model就是默认收集value值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 准备好一个容器--&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;</span><br><span class="line">        &lt;!-- 普通写法 --&gt;</span><br><span class="line">        &lt;!-- 单向数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br/&gt;</span><br><span class="line">        双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br/&gt; --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 简写 --&gt;</span><br><span class="line">        单向数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt;</span><br><span class="line">        双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;</span><br><span class="line">        &lt;!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素上 --&gt;</span><br><span class="line">        &lt;!-- &lt;h2 v-model:x=&quot;name&quot;&gt;你好啊&lt;/h2&gt; --&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。</span><br><span class="line">    </span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &#x27;#root&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name : &#x27;五邑大学&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="单向数据绑定运行结果"><a href="#单向数据绑定运行结果" class="headerlink" title="单向数据绑定运行结果:"></a>单向数据绑定运行结果:</h3><p><img src="/../upload/Vue/V1/2.png" alt="image"></p><h3 id="双向数据绑定运行结果"><a href="#双向数据绑定运行结果" class="headerlink" title="双向数据绑定运行结果:"></a>双向数据绑定运行结果:</h3><p><img src="/../upload/Vue/V1/3.png" alt="image"></p><h1 id="3-el和data的两种写法"><a href="#3-el和data的两种写法" class="headerlink" title="3.el和data的两种写法"></a>3.el和data的两种写法</h1><ul><li><ol><li><strong>el的两种写法:</strong></li></ol><ul><li><strong>(1).new Vue时候配置el属性。</strong></li><li><strong>(2).先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</strong></li></ul></li><li><ol start="2"><li><strong>data的两种写法</strong></li></ol><ul><li><strong>(1).对象式</strong></li><li><strong>(2).函数式</strong></li><li><strong>如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。(不能使用箭头函数)</strong></li></ul></li><li><ol start="3"><li><strong>一个重要的原则：</strong></li></ol><ul><li><strong>由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。(因为箭头函数没有this,他会向上指向windows)</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span> <span class="comment">//阻止 vue 在启动时生成生产提示。</span></span><br><span class="line">    <span class="comment">//el的两种写法</span></span><br><span class="line">    <span class="comment">/* const v = new Vue(&#123;</span></span><br><span class="line"><span class="comment">        //el:&#x27;#root&#x27;, //第一种写法</span></span><br><span class="line"><span class="comment">        data:&#123;</span></span><br><span class="line"><span class="comment">            name:&#x27;尚硅谷&#x27;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">    console.log(v)</span></span><br><span class="line"><span class="comment">    v.$mount(&#x27;#root&#x27;) //第二种写法(更为灵活) */</span></span><br><span class="line">    <span class="comment">//data的两种写法</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">        <span class="comment">//data的第一种写法：对象式</span></span><br><span class="line">        <span class="comment">/* data:&#123;</span></span><br><span class="line"><span class="comment">            name:&#x27;尚硅谷&#x27;</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">    <span class="comment">//data的第二种写法：函数式 (不能用箭头函数,因为箭头函数没有this,会向上指向windows)</span></span><br><span class="line">            <span class="title function_">data</span>(<span class="params"></span>)&#123; <span class="comment">//这里因为是对象函数,可以省略function和冒号:</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;@@@&#x27;</span>,<span class="variable language_">this</span>) <span class="comment">//此处的this是Vue实例对象</span></span><br><span class="line">                <span class="keyword">return</span>&#123;</span><br><span class="line">                    <span class="attr">name</span>:<span class="string">&#x27;五邑大学&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/Vue/V1/4.png" alt="image"></p><h1 id="4-理解MVVM模型-Model-View-ViewModel"><a href="#4-理解MVVM模型-Model-View-ViewModel" class="headerlink" title="4.理解MVVM模型(Model-View-ViewModel)"></a>4.理解MVVM模型(Model-View-ViewModel)</h1><ul><li><strong>1.M：模型(Model) ：对应data 中的数据</strong></li><li><strong>2.V：视图(View) ：模板</strong></li><li><strong>3.VM：视图模型(ViewModel) ： Vue 实例对象</strong></li></ul><h3 id="具体模型图"><a href="#具体模型图" class="headerlink" title="具体模型图"></a>具体模型图</h3><p><img src="/../upload/Vue/V1/5.png" alt="image"></p><h3 id="代码解析图如下"><a href="#代码解析图如下" class="headerlink" title="代码解析图如下"></a>代码解析图如下</h3><p><img src="/../upload/Vue/V1/6.png" alt="image"></p><h3 id="发现"><a href="#发现" class="headerlink" title="发现:"></a>发现:</h3><ul><li><strong>1.data中所有的属性，最后都出现在了vm身上</strong></li><li><strong>2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</strong></li></ul><h1 id="5-数据代理"><a href="#5-数据代理" class="headerlink" title="5.数据代理"></a>5.数据代理</h1><h2 id="1-回顾Object-defineProperty-函数的用法"><a href="#1-回顾Object-defineProperty-函数的用法" class="headerlink" title="1.回顾Object.defineProperty()函数的用法:"></a>1.回顾Object.defineProperty()函数的用法:</h2><ul><li><strong>Object.defineProperty()函的用法，顾名思义，这个方法就是给对象添加属性的，在Vue的底层，很多都用到这个方法，如数据劫持，数据代理，计算属性等…</strong></li><li><strong>语法:</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">语法格式:</span><br><span class="line">   <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,prop,description)</span><br><span class="line">        </span><br><span class="line">   <span class="attr">obj</span>: 必须 目标对象</span><br><span class="line">   <span class="attr">prop</span>: 必须 需要定义或修改的属性名字(你要修改的是哪一个属性)</span><br><span class="line">   <span class="attr">description</span>: 必须 目标属性所拥有的特性 (要改的属性有什么样的特性,说明,属性值),一般为对象形式</span><br><span class="line"></span><br><span class="line">   description的常用属性值:</span><br><span class="line">   <span class="number">1.</span><span class="attr">value</span>: 设置属性的值  默认为<span class="literal">undefined</span></span><br><span class="line">   <span class="number">2.</span><span class="attr">writable</span>: 值是否可以重写。<span class="literal">true</span> | <span class="literal">false</span>  默认为<span class="literal">false</span></span><br><span class="line">   <span class="number">3.</span><span class="attr">enumerable</span>: 目标属性是否可以被枚举。<span class="literal">true</span> | <span class="literal">false</span> 默认为 <span class="literal">false</span></span><br><span class="line">   <span class="number">4.</span><span class="attr">configurable</span>: 目标属性是否可以被删除或是否可以再次修改特性 <span class="literal">true</span> | <span class="literal">false</span>  默认为<span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//Object.defineProperty()方法用于定义新属性或修改原有的属性值</span></span><br><span class="line">    <span class="comment">// 先创建一个对象</span></span><br><span class="line">    <span class="keyword">let</span> a = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Cheung Pui Lam&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">address</span>: <span class="string">&#x27;五邑大学&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 常用的添加属性的方法1</span></span><br><span class="line">    a.<span class="property">sex</span> = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">    a.<span class="property">subject</span> = <span class="string">&#x27;电子信息工程&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常用的添加属性的方法2-Object.defineProperty()</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a , <span class="string">&#x27;age&#x27;</span> , &#123;<span class="comment">//这里将 age 这个属性改为了18</span></span><br><span class="line">        <span class="comment">//1.value: 设置或修改属性的值  默认为undefined</span></span><br><span class="line">        value : <span class="number">18</span>,</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//2.writable: 值是否可以重写。true | false  默认为false</span></span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,<span class="comment">//此时的age就不能被修改了!</span></span><br><span class="line">        <span class="comment">// 3.enumerable: 目标属性是否可以被枚举(就是遍历)。true | false 默认为 false</span></span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,<span class="comment">//此时这个age属性就无法被枚举(遍历)了!</span></span><br><span class="line">        <span class="comment">// 4.configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false  默认为false</span></span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">false</span><span class="comment">//表示现在的 age 属性不能被删除和修改特性(后面不能再修改)</span></span><br><span class="line">        &#125;)</span><br><span class="line">        a.<span class="property">age</span> = <span class="number">10</span>;<span class="comment">//age依然是 18  =&gt; 对应的是 writable: false 属性</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(a));<span class="comment">//使用keys()方法来遍历,没有出现 age属性 =&gt; 对应 enumerable: false 属性</span></span><br><span class="line">        <span class="keyword">delete</span> a.<span class="property">age</span>;<span class="comment">//但是结果依然有age属性 =&gt; 对应 configurable: true 属性</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/Vue/V1/7.png" alt="image"></p><h2 id="2-Object-defineProperty-函数的高级用法"><a href="#2-Object-defineProperty-函数的高级用法" class="headerlink" title="2.Object.defineProperty()函数的高级用法"></a>2.Object.defineProperty()函数的高级用法</h2><ul><li><strong>这里介绍 Object.defineProperty() 方法的两个高级用法(内置的get() 和 set() 方法)</strong><ul><li><strong>1.get() 方法:当有人读取目标对象的某一个属性时,就会执行这个该函数,且返回值就是目标属性(该属性)的值</strong></li><li><strong>set() 方法:当有人修改目标对象的某一个属性时,就会执行这个该函数,且返回值就是目标属性(该属性)的值</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">    <span class="comment">//Object.defineProperty()方法用于定义新属性或修改原有的属性值</span></span><br><span class="line">    <span class="comment">// 先创建一个对象</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">20</span>;<span class="comment">//这里设置一个冰凉用于传递和接收 age属性的属性值 </span></span><br><span class="line">    <span class="keyword">let</span> a = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Cheung Pui Lam&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: num,</span><br><span class="line">        <span class="attr">address</span>: <span class="string">&#x27;五邑大学&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常用的添加属性的方法2-Object.defineProperty()</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a , <span class="string">&#x27;age&#x27;</span> , &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;<span class="comment">//每当读取 age属性(目标属性)时就会调用这个函数</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;给属性被读取了!&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> num;<span class="comment">//一定要有返回值</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;<span class="comment">//每当修改 age属性(目标属性)时就会调用这个函数</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;该属性被修改了!,且该属性值是&#x27;</span>, value );</span><br><span class="line">            num = value</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/Vue/V1/8.png" alt="image"><br><img src="/../upload/Vue/V1/9.png" alt="image"></p><h2 id="2-理解数据代理"><a href="#2-理解数据代理" class="headerlink" title="2.理解数据代理"></a>2.理解数据代理</h2><ul><li><strong>所谓的数据代理,实际上就是通过一个对象代理另一个对象中属性的操作(读&#x2F;写),说白了就是通过 对象1 操作 对象2, 对象1 能够访问和修改 对象2 的一些属性和方法</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）--&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> obj = &#123;<span class="attr">x</span>:<span class="number">100</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> obj2 = &#123;<span class="attr">y</span>:<span class="number">200</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj2,<span class="string">&#x27;x&#x27;</span>,&#123;<span class="comment">//给obj2添加一个x属性,返回的是obj的x值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">get</span>(<span class="params"></span>)&#123;<span class="comment">//每当读取obj2中的x属性就会返回obj的x值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">return</span> obj.<span class="property">x</span><span class="comment">//这里相当于给obj2添加属性 x:100</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">set</span>(<span class="params">value</span>)&#123;<span class="comment">//每当修改obj2的x值,就会将该值传递给obj的x</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                obj.<span class="property">x</span> = value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(obj,obj2);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果-4"><a href="#运行结果-4" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/Vue/V1/10.png" alt="image"><br><img src="/../upload/Vue/V1/11.png" alt="image"><br><strong>表示了我们可以通过obj2一样可以操作obj,这就是数据代理</strong></p><h2 id="3-Vue当中是如何应用数据代理的？"><a href="#3-Vue当中是如何应用数据代理的？" class="headerlink" title="3.Vue当中是如何应用数据代理的？"></a>3.Vue当中是如何应用数据代理的？</h2><ul><li><strong>就拿插值语法来讲，我们在实例化对象的时候会在Vue构造函数中传入data{}对象，给里面填入一些属性，而这些属性在实例化对象的时候就通过数据代理的方式传送给实例化对象</strong></li></ul><h3 id="原理如图所示"><a href="#原理如图所示" class="headerlink" title="原理如图所示:"></a>原理如图所示:</h3><p><img src="/../upload/Vue/V1/12.png" alt="image"></p><ul><li><strong>代码解析:</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">    <span class="number">1.</span><span class="title class_">Vue</span>中的数据代理：</span><br><span class="line">        通过vm对象来代理data对象中属性的操作（读/写）</span><br><span class="line">    <span class="number">2.</span><span class="title class_">Vue</span>中数据代理的好处：</span><br><span class="line">        更加方便的操作data中的数据</span><br><span class="line">    <span class="number">3.</span>基本原理：</span><br><span class="line">        通过<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>()把data对象中所有属性添加到vm上。</span><br><span class="line">        为每一个添加到vm上的属性，都指定一个getter/setter。</span><br><span class="line">        在getter/setter内部去操作（读/写）data中对应的属性。</span><br><span class="line">      --&gt;</span><br><span class="line">     &lt;!-- 准备好一个容器--&gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">h2</span>&gt;</span>学校地址：&#123;&#123;school&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span> <span class="comment">//阻止 vue 在启动时生成生产提示。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">name</span>:<span class="string">&#x27;zpl&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">school</span>:<span class="string">&#x27;五邑大学&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(vm);<span class="comment">//输出实例对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">name</span> === vm.<span class="property">_data</span>.<span class="property">name</span>);<span class="comment">//true,说明原Vue构造函数里面的data就是vm里面的_data</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果-5"><a href="#运行结果-5" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/Vue/V1/13.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板语法,数据绑定,数据代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数和原型(2)-继承和类</title>
      <link href="/2022/07/29/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B2/"/>
      <url>/2022/07/29/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B2/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h1 id="1-call-方法介绍"><a href="#1-call-方法介绍" class="headerlink" title="1.call()方法介绍"></a>1.call()方法介绍</h1><ul><li><strong>ES6之前并没有给我们提供 extends 继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。</strong></li><li><strong>Call()方法的作用:</strong><ul><li><strong>1.调用指向函数</strong></li><li><strong>2.修改函数的this指向</strong></li></ul></li><li><strong>语法格式:</strong><ul><li><strong>fun.call(thisArg, arg1, arg2, …)</strong></li><li><strong>1.thisArg ：当前调用函数 this 的指向对象</strong></li><li><strong>2.arg1，arg2：传递的其他参数</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我想喝手磨咖啡&#x27;</span>);<span class="comment">//正常输出我想喝手磨咖啡</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">//window</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y);<span class="comment">//NaN,这时添加参数</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// fn();</span></span><br><span class="line"><span class="comment">// 1. call() 可以调用函数</span></span><br><span class="line">fn.<span class="title function_">call</span>();<span class="comment">//与fun();的结果一致,表示call()方法也有函数调用的功能</span></span><br><span class="line"><span class="comment">// 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象</span></span><br><span class="line"><span class="comment">//原本这个函数的指向应该是window,现在改了滞后它就指向o这个对象了</span></span><br><span class="line">fn.<span class="title function_">call</span>(o, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//3 这时又参数传进来了</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/prototype/12.png" alt="image"></p><h1 id="2-借用构造函数继承父类型属性"><a href="#2-借用构造函数继承父类型属性" class="headerlink" title="2.借用构造函数继承父类型属性"></a>2.借用构造函数继承父类型属性</h1><ul><li><strong>核心原理： 通过 call() 把父类型的 this 改为指向子类型的 this ，这样就可以实现子类型继承父类型的属性。</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 借用父构造函数继承属性</span></span><br><span class="line"> <span class="comment">// 1. 父构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里的 this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 .子构造函数 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">uname, age, score</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里的 this 指向子构造函数的对象实例</span></span><br><span class="line">    <span class="comment">// 因为我们知道call()方法是可以修改指定函数的this指向的</span></span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, uname, age);<span class="comment">//这里将Father的中的this指向改为了子构造函数中的this指向(即这里的this是子构造函数的this指向)</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">score</span> = score;<span class="comment">//给子构造函数创建一个新的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son);<span class="comment">//后面是可以正常输出结果的</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/prototype/13.png" alt="image"></p><h1 id="3-借用原型对象继承父类型方法"><a href="#3-借用原型对象继承父类型方法" class="headerlink" title="3.借用原型对象继承父类型方法"></a>3.借用原型对象继承父类型方法</h1><ul><li><strong>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。</strong><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理:"></a>核心原理:</h3><ul><li><strong>1.将子类所共享的方法提取出来，让子类的 prototype 原型对象 &#x3D; new 父类()</strong></li><li><strong>2.本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</strong></li><li><strong>3.将子类的 constructor 从新指向子类的构造函数</strong><br><img src="/../upload/prototype/14.png" alt="image"></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 借用父构造函数继承属性</span></span><br><span class="line"><span class="comment">// 1. 父构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">money</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">100000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 .子构造函数 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">uname, age, score</span>) &#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, uname, age);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">score</span> = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="comment">// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span>;</span><br><span class="line"><span class="comment">// 这个是子构造函数专门的方法</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">exam</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;孩子要考试&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son);<span class="comment">//里面具有自己设置的exam方法也有沿着原型链向上查找的money方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//里面只有公共方法money,表示son添加的方法并没用影响到Father</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>);<span class="comment">//利用constructor指回Son原型对象</span></span><br></pre></td></tr></table></figure><h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/prototype/15.png" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><ul><li><strong>我们可以通过原型对象来继承方法,因为我们知道,共享的方法是写在原型对象里面的,这里的Father原型对象里面有一个money的方法,那我们的子构造函数怎样去使用这个money方法呢?这里我们不能直接利用子原型对象&#x3D;父原型对象这种方法,因为如果这样的话,你一旦修改了子原型对象,那么父原型对象也会跟着一起被修改,所以这里我们需要将构造函数实例化,创建一个实例化对象,让我们的子原型对象指向这个实例化对象,但这个实例化对象里面有一个属性:__proto__指向Father的原型对象的,所以我们的子原型对象是可以拿到这个money方法的并且无论我怎样修改子原型对象都不会影响到父原型对象,因为这里的子原型对象是指向实例化对象的,实例化对象和原型对象的地址是不一样的</strong></li></ul><h1 id="4-ES6类的本质"><a href="#4-ES6类的本质" class="headerlink" title="4.ES6类的本质"></a>4.ES6类的本质</h1><ul><li><strong>类的本质是一个函数,类实质上就是ES5当中的构造函数,基本上是一模一样的,我们看下面的代码和结果展示:</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 之前通过 构造函数+ 原型实现面向对象 编程</span></span><br><span class="line"><span class="comment">// (1) 构造函数有原型对象prototype </span></span><br><span class="line"><span class="comment">// (2) 构造函数原型对象prototype 里面有constructor 指向构造函数本身</span></span><br><span class="line"><span class="comment">// (3) 构造函数可以通过原型对象添加方法</span></span><br><span class="line"><span class="comment">// (4) 构造函数创建的实例对象有__proto__ 原型指向 构造函数的原型对象</span></span><br><span class="line"><span class="comment">// ES6 通过 类 实现面向对象编程 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Star</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Star</span>);<span class="comment">//function 说明类的本质是一个函数</span></span><br><span class="line"><span class="comment">// 1. 类的本质其实还是一个函数 我们也可以简单的认为 类就是 构造函数的另外一种写法</span></span><br><span class="line"><span class="comment">// (1) 类有原型对象prototype </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//</span></span><br><span class="line"><span class="comment">// (2) 类原型对象prototype 里面有constructor 指向类本身</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>);<span class="comment">//结果 class Star 指向类本身</span></span><br><span class="line"><span class="comment">// (3)类可以通过原型对象添加方法</span></span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冰雨&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(ldh);<span class="comment">//里面存在__proto__属性 , 和sing方法</span></span><br><span class="line"><span class="comment">// (4) 类创建的实例对象有__proto__ 原型指向 类的原型对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">__proto__</span> === <span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/prototype/16.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> 面向对象 </category>
          
          <category> 原型和原型链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造函数和原型,原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数和原型(1)</title>
      <link href="/2022/07/29/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B1/"/>
      <url>/2022/07/29/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-初识构造函数和原型"><a href="#1-初识构造函数和原型" class="headerlink" title="1.初识构造函数和原型"></a>1.初识构造函数和原型</h1><ul><li><strong>Es6以前我们面向对象是使用构造函数来实现的，将一些对象的公共方法和属性放在构造函数里面，再通过构造函数来实例化对象，这种方法虽然好用，但是存在问题：浪费内存</strong><br><img src="/../upload/prototype/1.png" alt="image"></li><li><strong>对象当中的属性还好说，但是方法(函数)是复杂是数据类型,当我们在创建对象的时候,这个方法会单独的再开辟一个内存空间,来存放这个复杂的数据类型,那么再次调用一个类来创建对象,他里面又有这个sing方法,那又会在开辟一个内存空间来存放这个方法(函数),就相当于开辟两个内存空间来存放相同的方法(函数),那么我有100实例对象呢?而且开辟内存空间还需要时间,如果实例对象过多就会大量的浪费时间</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印一下判断两个sing是否再同一个内存空间</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">sing</span> === zxy.<span class="property">sing</span>);<span class="comment">//false</span></span><br><span class="line"><span class="comment">// 说明:构造函数每一次实例化都西昂都要开辟一块新的内存空间来存放公共方法(函数)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/prototype/2.png" alt="image"></p><h1 id="2-构造函数原型-prototype"><a href="#2-构造函数原型-prototype" class="headerlink" title="2.构造函数原型(prototype)"></a>2.构造函数原型(prototype)</h1><ul><li><strong>JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</strong></li><li><strong>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</strong></li></ul><h2 id="1-原型是什么-？"><a href="#1-原型是什么-？" class="headerlink" title="1.原型是什么 ？"></a>1.原型是什么 ？</h2><ul><li><strong>一个对象，是构造函数内置的一个对象,我们也称为 prototype 为原型对象。</strong></li></ul><h2 id="2-原型的作用是什么-？"><a href="#2-原型的作用是什么-？" class="headerlink" title="2.原型的作用是什么 ？"></a>2.原型的作用是什么 ？</h2><ul><li><strong>共享方法(将一些公共方法存进去解决构造函数内存浪费的问题)。</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 构造函数的问题. </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="comment">// this.sing = function() &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;我会唱歌&#x27;);</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将公共方法(函数)放进构造函数的原型当中</span></span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">sing</span> === zxy.<span class="property">sing</span>);<span class="comment">//true 两个sing方法的地址一致</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="title class_">Star</span>);<span class="comment">//prototpye中有sing方法</span></span><br><span class="line">ldh.<span class="title function_">sing</span>();</span><br><span class="line">zxy.<span class="title function_">sing</span>();</span><br><span class="line"><span class="comment">// 2. 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/prototype/3.png" alt="image"></p><h1 id="3-为什么实例化对象能够访问原型对象身上的prototype对象呢"><a href="#3-为什么实例化对象能够访问原型对象身上的prototype对象呢" class="headerlink" title="3.为什么实例化对象能够访问原型对象身上的prototype对象呢?"></a>3.为什么实例化对象能够访问原型对象身上的prototype对象呢?</h1><ul><li><strong>因为有__proto__的存在,实例化对象的身上都会有一个属性 <strong>proto</strong> 指向构造函数的 prototype 原型对象，之所以我们的实例化对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 <strong>proto</strong> 原型的存在。</strong><ul><li><strong>1.__proto__对象原型和原型对象 prototype 是等价的</strong></li><li><strong>2.__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性(赋值等操作)，它只是内部指向原型对象 prototype</strong><br><img src="/../upload/prototype/4.png" alt="image"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">19</span>);</span><br><span class="line">ldh.<span class="title function_">sing</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh); <span class="comment">// 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">__proto__</span> === <span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"><span class="comment">// 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing</span></span><br><span class="line"><span class="comment">// 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/prototype/5.png" alt="image"></p><h1 id="4-constructor-构造函数"><a href="#4-constructor-构造函数" class="headerlink" title="4.constructor  构造函数"></a>4.constructor  构造函数</h1><ul><li><strong>对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</strong></li><li><strong>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</strong></li><li><strong>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样赋值方法太过麻烦复杂,代码量多</span></span><br><span class="line"><span class="comment">// Star.prototype.sing = function() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;我会唱歌&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">// Star.prototype.movie = function() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;我会演电影&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数</span></span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line"><span class="comment">// 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</span></span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Star</span>,</span><br><span class="line">    <span class="attr">sing</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">movie</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会演电影&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//指向的是同一个对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">__proto__</span>);<span class="comment">//指向的是同一个对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>);<span class="comment">//指向的是同一个对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">__proto__</span>.<span class="property">constructor</span>);<span class="comment">//指向的是同一个对象</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/prototype/6.png" alt="image"></p><h1 id="5-构造函数-实例话对象-原型对象三者之间的关系-箭头是指向关系"><a href="#5-构造函数-实例话对象-原型对象三者之间的关系-箭头是指向关系" class="headerlink" title="5.构造函数,实例话对象,原型对象三者之间的关系(箭头是指向关系)"></a>5.构造函数,实例话对象,原型对象三者之间的关系(箭头是指向关系)</h1><p><img src="/../upload/prototype/7.png" alt="image"></p><h1 id="6-原型链"><a href="#6-原型链" class="headerlink" title="6.原型链"></a>6.原型链</h1><ul><li><strong>只要是对象(原型对象也是对象),就会都会有一个原型(<strong>proto</strong>),这个原型指向的是原型对象(prototype),那么逐次查找,逐次指向就会产生一条路,这条路就是原型链</strong><br><img src="/../upload/prototype/8.png" alt="image"></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 1. 只要是对象就有__proto__ 原型, 指向原型对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>);<span class="comment">//指向的是)Object(大写的O)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"><span class="comment">// 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>);<span class="comment">//null</span></span><br><span class="line"><span class="comment">// 3. 我们Object.prototype原型对象里面的__proto__原型  指向为 null</span></span><br></pre></td></tr></table></figure><h1 id="7-对象成员的查找规则-顺着原型链的指向-向上查找"><a href="#7-对象成员的查找规则-顺着原型链的指向-向上查找" class="headerlink" title="7.对象成员的查找规则(顺着原型链的指向,向上查找)"></a>7.对象成员的查找规则(顺着原型链的指向,向上查找)</h1><ul><li><strong>1.当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。(就近原则,先看看自己身上有没有,没有再向上查找)</strong></li><li><strong>2.如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。</strong></li><li><strong>3.如果还没有就查找原型对象的原型（Object的原型对象）。</strong></li><li><strong>4.依此类推一直找到 Object 为止（null）。</strong></li><li><strong>5.__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sex</span> = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"><span class="comment">// Object.prototype.sex = &#x27;男&#x27;;</span></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// ldh.sex = &#x27;男&#x27;;</span></span><br><span class="line"><span class="comment">// console.log(ldh.sex);//男,自己身上有</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">sex</span>);<span class="comment">//女,自己身上没有,但是Star构造函数身上有</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//身上有toString()方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh);<span class="comment">//此时身上没有sex属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//Star身上有sex属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="title function_">toString</span>());<span class="comment">//这里可以使用Object身上的toString方法</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果-4"><a href="#运行结果-4" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/prototype/9.png" alt="image"><br><img src="/../upload/prototype/10.png" alt="image"></p><h1 id="8-对象原型还可以扩展内置对象"><a href="#8-对象原型还可以扩展内置对象" class="headerlink" title="8.对象原型还可以扩展内置对象"></a>8.对象原型还可以扩展内置对象</h1><ul><li><strong>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</strong></li><li><strong>注意：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype &#x3D; {} ，只能是 Array.prototype.xxx &#x3D; function(){} 的方式。</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型对象的应用 扩展内置对象方法</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sum</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum += <span class="variable language_">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不能使用这种方法(这种方法相当于赋值,会覆盖掉原来的内置方法)</span></span><br><span class="line"><span class="comment">// Array.prototype = &#123;</span></span><br><span class="line"><span class="comment">//     sum: function() &#123;</span></span><br><span class="line"><span class="comment">//         var sum = 0;</span></span><br><span class="line"><span class="comment">//         for (var i = 0; i &lt; this.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             sum += this[i];</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return sum;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">sum</span>());<span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//里面有sum()方法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>);<span class="comment">//实例化内置对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1.<span class="title function_">sum</span>());<span class="comment">//66,证明可以调用内置对象中新增的sum方法</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果-里面存在sum-方法"><a href="#运行结果-里面存在sum-方法" class="headerlink" title="运行结果:(里面存在sum()方法)"></a>运行结果:(里面存在sum()方法)</h3><p><img src="/../upload/prototype/11.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> 面向对象 </category>
          
          <category> 原型和原型链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造函数和原型,原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios学习笔记(4)-取消请求及批量发送请求</title>
      <link href="/2022/07/27/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82%E5%8F%8A%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/"/>
      <url>/2022/07/27/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82%E5%8F%8A%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="1-axios取消请求的基本使用"><a href="#1-axios取消请求的基本使用" class="headerlink" title="1.axios取消请求的基本使用"></a>1.axios取消请求的基本使用</h1><ul><li><strong>axios取消请求方式一般有两种,我们这里学习使用CancelToken的构造函数的方式取消请求</strong></li><li><strong>axios有一个CancelToken属性，他是一个类，用于获取取消请求的cancel方法，获取了该方法之后就可以在合适的地方执行cancel()取消请求了。这种方式比较麻烦，但是可以用于取消多个请求</strong></li></ul><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下:"></a>代码如下:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.请求拦截器(这里的请求拦截器什么也不走,就接收数据返回数据)</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器执行了&#x27;</span>,config);</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.响应拦截器(比请求拦截器应用得更广泛,项目开发没有不用相应拦截器的)</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="comment">// 成功的回调</span></span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器成功的回调执行了!&#x27;</span>, response);</span><br><span class="line">        <span class="keyword">return</span> response.<span class="property">data</span>                  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 失败的回调</span></span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 项目中常用的处理失败</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器失败的回调执行了!&#x27;</span>);</span><br><span class="line">        <span class="title function_">alert</span>(error);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建取消请求设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="comment">// 做变量提升,将块级作用域中的取消标识拉出到全局作用域中</span></span><br><span class="line"><span class="keyword">let</span> cancel</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目开发中的常用嵌套 async和await(只要成功的结果,失败的结果由相应拦截器负责捕获和输出)</span></span><br><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        url : <span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置取消请求功能属性</span></span><br><span class="line">        cancelToken : <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="function">(<span class="params">c</span>)=&gt;</span>&#123;<span class="comment">//这里的c变量是一个函数</span></span><br><span class="line">            <span class="comment">// console.log(c);</span></span><br><span class="line">            cancel = c;<span class="comment">//这里一定不能加括号,加括号就相当于调用了取消请求</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功了&#x27;</span>,response);</span><br><span class="line">    &#125; , <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败了&#x27;</span>,error);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给按钮绑定取消发送功能</span></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(cancel);</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="string">&#x27;我手动取消了请求!&#x27;</span>);<span class="comment">//取消请求,里面可以传入参数表示取消请求的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果如下所示"><a href="#结果如下所示" class="headerlink" title="结果如下所示:"></a>结果如下所示:</h2><p><img src="/../upload/axios/21.png" alt="image"></p><h2 id="这时我们可以输出c看看-c的本质是一个函数-cancel的缩写"><a href="#这时我们可以输出c看看-c的本质是一个函数-cancel的缩写" class="headerlink" title="这时我们可以输出c看看,c的本质是一个函数,cancel的缩写"></a><strong>这时我们可以输出c看看,c的本质是一个函数,cancel的缩写</strong></h2><p><img src="/../upload/axios/22.png" alt="image"></p><h1 id="2-isCancel方法的基本使用"><a href="#2-isCancel方法的基本使用" class="headerlink" title="2.isCancel方法的基本使用"></a>2.isCancel方法的基本使用</h1><ul><li><strong>axios中存在一个判断取消请求的方法:isCancel(),这个方法顾名思义用于判断请求状态是否为取消,因为取消请求走的也是失败的回调(axios中有两个回调,一个是成功的回调,一个是失败的回调)</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建取消请求设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="comment">// 创建判断是否取消请求方法变量</span></span><br><span class="line"><span class="keyword">const</span> isCancel = axios.<span class="property">isCancel</span>;</span><br><span class="line"><span class="comment">// 做变量提升,将块级作用域中的取消标识拉出到全局作用域中</span></span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目开发中的常用嵌套 async和await(只要成功的结果,失败的结果由相应拦截器负责捕获和输出)</span></span><br><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断外层的cancel是否有值,有值则取消上一次发送,重新发送一次请求</span></span><br><span class="line">    <span class="keyword">if</span> (cancel) <span class="title function_">cancel</span>()<span class="comment">//用户多次点击取消上一次请求重新发送</span></span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        url : <span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>,</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 设置取消请求功能属性</span></span><br><span class="line">        cancelToken : <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="function">(<span class="params">c</span>)=&gt;</span>&#123;<span class="comment">//这里的c变量是一个函数</span></span><br><span class="line">            <span class="comment">// c();</span></span><br><span class="line">            <span class="comment">// console.log(c);</span></span><br><span class="line">            cancel = c;<span class="comment">//这里一定不能加括号,加括号就相当于调用了取消请求</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功了&#x27;</span>,response);</span><br><span class="line">    &#125; , <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户手动取消的请求,原因是&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败了&#x27;</span>,error);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给按钮绑定取消发送功能</span></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(cancel);</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="string">&#x27;我手动取消了请求!&#x27;</span>);<span class="comment">//取消请求,里面可以传入参数表示取消的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结果如下所示-1"><a href="#结果如下所示-1" class="headerlink" title="结果如下所示:"></a>结果如下所示:</h2><p><img src="/../upload/axios/23.png" alt="image"></p><h1 id="重点-结合拦截器使用-统一处理多次点击发送请求和取消请求"><a href="#重点-结合拦截器使用-统一处理多次点击发送请求和取消请求" class="headerlink" title="重点:结合拦截器使用(统一处理多次点击发送请求和取消请求)"></a>重点:结合拦截器使用(统一处理多次点击发送请求和取消请求)</h1><ul><li><strong>请求拦截器应用场景:判断用户是否多次点击发送请求</strong></li><li><strong>响应拦截器应用场景:统一处理错误信息,判断是真正的请求错误还是用户手动取消请求</strong></li></ul><h2 id="源码如下"><a href="#源码如下" class="headerlink" title="源码如下:"></a>源码如下:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.请求拦截器(判断用户是否多次点击发送请求)</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 判断外层的cancel是否有值,有值则取消上一次发送,重新发送一次请求</span></span><br><span class="line">    <span class="keyword">if</span> (cancel) <span class="title function_">cancel</span>(<span class="string">&#x27;取消了&#x27;</span>)<span class="comment">//用户多次点击取消上一次请求重新发送</span></span><br><span class="line"></span><br><span class="line">    config.<span class="property">cancelToken</span> = <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="function">(<span class="params">c</span>)=&gt;</span>&#123;<span class="comment">//这里的c变量是一个函数</span></span><br><span class="line">        cancel = c;<span class="comment">//这里一定不能加括号,加括号就相当于调用了取消请求</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器执行了&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.响应拦截器(统一处理错误信息,判断是真正的请求错误还是用户手动取消请求)</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="comment">// 成功的回调</span></span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器成功的回调执行了!&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> response.<span class="property">data</span>                  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 失败的回调</span></span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户手动取消的请求,原因是&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败了&#x27;</span>,error);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中断Promise链(一旦发生错误就中断,包括自己手动取消)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建取消请求设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="comment">// 4.创建判断是否取消请求方法变量</span></span><br><span class="line"><span class="keyword">const</span> isCancel = axios.<span class="property">isCancel</span>;</span><br><span class="line"><span class="comment">// 做变量提升,将块级作用域中的取消标识拉出到全局作用域中</span></span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目开发中的常用嵌套 async和await(只要成功的结果,失败的结果由相应器负责捕获和输出)</span></span><br><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给按钮绑定取消发送功能</span></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(cancel);</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="string">&#x27;我手动取消了请求!&#x27;</span>);<span class="comment">//取消请求,里面可以传入参数表示取消请求的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果解析"><a href="#结果解析" class="headerlink" title="结果解析:"></a>结果解析:</h2><ul><li><strong>这样调用起来逻辑清晰,请求拦截器统一处理用户的多次点击事件发送请求,响应拦截器则负责统一处理失败事件,无论是手动取消请求还是真正的错误!集中处理!!</strong></li></ul><h1 id="批量发送请求"><a href="#批量发送请求" class="headerlink" title="批量发送请求"></a>批量发送请求</h1><ul><li><strong>axios给我们提供了一个非常优秀的封装,能够让我们批量的发送请求,实现原理其实就跟Promise里面的all方法差不多,这里也是用all方法,去他代码如下,有详细注释</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册点击事件</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 批量发送的原理:使用all方法(与Promise.all基本一致:全部成功全部返回,一个失败,就返回失败的那个原因)</span></span><br><span class="line">    axios.<span class="title function_">all</span>([<span class="comment">//用all方法,将想要同时发送的请求封装成一个数组</span></span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/posts/1&#x27;</span>),</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>),</span><br><span class="line">    ]).<span class="title function_">then</span>(<span class="comment">//这里用.then方法接收</span></span><br><span class="line">        <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response);<span class="comment">//同时发送同时返回,绝不会有先后顺序</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span> =&gt;</span> &#123;error&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结果如下所示-2"><a href="#结果如下所示-2" class="headerlink" title="结果如下所示:"></a>结果如下所示:</h2><p><img src="/../upload/axios/24.png" alt="image"></p><h3 id="这里我们可以看到-这两个请求是同时发送出去的"><a href="#这里我们可以看到-这两个请求是同时发送出去的" class="headerlink" title="这里我们可以看到,这两个请求是同时发送出去的"></a>这里我们可以看到,这两个请求是同时发送出去的</h3><p><img src="/../upload/axios/25.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改butterfly(4)-添加音乐播放器(aplayer)</title>
      <link href="/2022/07/26/%E9%AD%94%E6%94%B9butterfly4/"/>
      <url>/2022/07/26/%E9%AD%94%E6%94%B9butterfly4/</url>
      
        <content type="html"><![CDATA[<h1 id="添加音乐播放器-aplayer"><a href="#添加音乐播放器-aplayer" class="headerlink" title="添加音乐播放器(aplayer)"></a>添加音乐播放器(aplayer)</h1><ul><li><strong><a href="https://github.com/MoePlayer/hexo-tag-aplayer">官方文档-添加插件</a></strong></li><li><strong>就拿 <a href="https://cheung-pui-lam.github.io/">我的博客</a> 为例</strong></li></ul><h2 id="教程开始"><a href="#教程开始" class="headerlink" title="教程开始"></a>教程开始</h2><ul><li><ol><li><strong>首先安装 hexo-tag-aplayer 这款插件。执行如下指令：(在你博客根目录下打开控制台安装)</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li><strong>如图所示:(打开控制台方式)</strong><br><img src="/../upload/mogai4/1.png" alt="image"><br><img src="/../upload/mogai4/2.png" alt="image"><br><strong>点击回车!开始安装</strong></li></ol></li><li><ol start="3"><li><strong>随后在你博客的根目录下的_config.yml(切记是根目录下,不是主题文件下)添加音乐播放器模块,如下所示</strong>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">    meting: true</span><br><span class="line">    asset_inject: false</span><br></pre></td></tr></table></figure><img src="/../upload/mogai4/3.png" alt="image"></li></ol></li><li><ol start="4"><li><strong>开启主题配置文件中_config.yml的 aplayerInject,(切记这次是你主题文件下的_config.yml)</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aplayerInject:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure><img src="/../upload/mogai4/4.png" alt="image"></li></ol></li><li><ol start="5"><li><strong>到这里音乐页面就基本配置完成了,下面是音源配置教程</strong></li></ol></li></ul><h1 id="音源配置教程"><a href="#音源配置教程" class="headerlink" title="音源配置教程"></a>音源配置教程</h1><ul><li><strong>以本博客为例，在博客的音乐页面（\source\music\index.md文件）添加如下代码：</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% meting &quot;7539051570&quot; &quot;netease&quot; &quot;playlist&quot; &quot;mutex:false&quot; &quot;listmaxheight:400px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125;</span><br></pre></td></tr></table></figure></li><li><strong>或者也可以直接添加html格式</strong><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aplayer&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;7539051570&quot;</span> <span class="attr">data-server</span>=<span class="string">&quot;netease&quot;</span> <span class="attr">data-type</span>=<span class="string">&quot;artist&quot;</span> <span class="attr">data-preload</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">data-theme</span>=<span class="string">&quot;#3F51B5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/../upload/mogai4/5.png" alt="image"></li></ul><h2 id="下面再来讲讲这些属性的含义"><a href="#下面再来讲讲这些属性的含义" class="headerlink" title="下面再来讲讲这些属性的含义:"></a>下面再来讲讲这些属性的含义:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data-id    require 歌曲id/播放列表id/专辑id/搜索关键字</span><br><span class="line">data-serverrequire 音乐平台：网易、腾讯、酷狗、夏米、百度</span><br><span class="line">data-typerequire 歌曲、播放列表、专辑、搜索、艺术家</span><br><span class="line">data-fixedfalse 启用固定模式</span><br><span class="line">data-minifalse 启用最小模式</span><br><span class="line">data-autoplayfalse音频自动播放</span><br><span class="line">data-theme #2980b9  主题颜色</span><br><span class="line">data-loop all      循环播放，值：“all”、“one”、“none”</span><br><span class="line">data-order list  播放顺序，值：“list”，“random”</span><br><span class="line">data-preload auto  数据的预处理加载 值：“无”、“元数据”、“自动”</span><br><span class="line">data-volume 0.7音量调节</span><br><span class="line">data-mutextrue防止同时播放多条音乐,在不同的页面</span><br><span class="line">data-lrctype0歌词的展现形式</span><br><span class="line">data-listfoldedfalse指示是否应首先折叠列表</span><br><span class="line">data-listmaxheight340px最大列表高度</span><br><span class="line">data-storagenamemetingjs设置存储密钥</span><br></pre></td></tr></table></figure><ul><li><strong>require 代表着這些參數是必須要使用的，其它的參數則可以根據自己需要配置。</strong><h3 id="常用的选项如下所示"><a href="#常用的选项如下所示" class="headerlink" title="常用的选项如下所示:"></a>常用的选项如下所示:</h3></li><li><strong>server可选：netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。建议网易云</strong></li><li><strong>type可选：song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手）。添加单曲选的歌曲，歌单选择playlist，可以自行尝试。</strong></li><li><strong>id获取示例: 打开网易云音乐，选择喜欢的歌单，在网页版打开，获取歌单list，填入即可。使用的时候将上边的ID号换为自己喜欢的歌单即可。注意歌单中不能包括VIP音乐，否则无法解析。建议单独建立一个歌单，以后有喜欢的音乐添加进去，网页也会自动同步添加。</strong></li><li><strong>lrcType设置为 -1默认显示歌词，放在fixed模式下比较合适</strong></li></ul><h1 id="歌单的获取-id属性的歌单导入"><a href="#歌单的获取-id属性的歌单导入" class="headerlink" title="歌单的获取:(id属性的歌单导入)"></a>歌单的获取:(id属性的歌单导入)</h1><p><img src="/../upload/mogai4/6.png" alt="image"></p><ul><li><strong>获取歌单的id后导入指定属性即可!</strong></li></ul><h1 id="最后的成品展示"><a href="#最后的成品展示" class="headerlink" title="最后的成品展示:"></a>最后的成品展示:</h1><p><img src="/../upload/mogai4/7.png" alt="image"></p><h1 id="拓展功能-全局吸底音乐播放器-aplayer-请观看官方文档教程"><a href="#拓展功能-全局吸底音乐播放器-aplayer-请观看官方文档教程" class="headerlink" title="拓展功能:全局吸底音乐播放器(aplayer)请观看官方文档教程"></a>拓展功能:全局吸底音乐播放器(aplayer)请观看官方文档教程</h1><h2 id="官方文档-全局吸底"><a href="#官方文档-全局吸底" class="headerlink" title="官方文档-全局吸底"></a><a href="https://butterfly.js.org/posts/507c070f/">官方文档-全局吸底</a></h2><p><img src="/../upload/mogai4/8.gif" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔改butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改butterfly-添加标签云</title>
      <link href="/2022/07/26/%E9%AD%94%E6%94%B9butterfly/"/>
      <url>/2022/07/26/%E9%AD%94%E6%94%B9butterfly/</url>
      
        <content type="html"><![CDATA[<h1 id="添加标签云"><a href="#添加标签云" class="headerlink" title="添加标签云"></a>添加标签云</h1><ul><li><a href="https://github.com/D0n9X1n/hexo-tag-cloud/blob/master/README.ZH.md">官方文档</a></li></ul><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程:"></a>安装流程:</h2><ul><li><strong>进入到 hexo 的根目录，然后在 package.json 中添加依赖: “hexo-tag-cloud”: “2.1.*”</strong></li><li><strong>执行 npm install 命令</strong></li><li><strong>然后需要你去修改主题的 tagcloud 的模板，这个依据你的主题而定</strong></li></ul><h3 id="就那我的主题为例-我的主题是butterfly"><a href="#就那我的主题为例-我的主题是butterfly" class="headerlink" title="就那我的主题为例,我的主题是butterfly"></a><strong>就那我的主题为例,我的主题是butterfly</strong></h3><ul><li><strong>首先找到 Butterfly&#x2F;layout&#x2F;includes&#x2F;widget&#x2F;card_tags.pug 文件</strong></li><li><strong>然后将文件内容转换成如下代码:</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> site.<span class="property">tags</span>.<span class="property">length</span></span><br><span class="line">  .<span class="property">card</span>-widget.<span class="property">card</span>-tags</span><br><span class="line">    .<span class="property">card</span>-content</span><br><span class="line">      .<span class="property">item</span>-headline</span><br><span class="line">        i.<span class="property">fa</span>.<span class="property">fa</span>-<span class="title function_">tags</span>(aria-hidden=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">        span= <span class="title function_">_p</span>(<span class="string">&#x27;aside.card_tags&#x27;</span>)</span><br><span class="line">        <span class="title function_">script</span>(type=<span class="string">&quot;text/javascript&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span> src=<span class="string">&quot;/js/tagcloud.js&quot;</span>)</span><br><span class="line">        <span class="title function_">script</span>(type=<span class="string">&quot;text/javascript&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span> src=<span class="string">&quot;/js/tagcanvas.js&quot;</span>)</span><br><span class="line">        #myCanvasContainer.<span class="property">widget</span>.<span class="title function_">tagcloud</span>(align=<span class="string">&#x27;center&#x27;</span>, style=<span class="string">&#x27;width=100%;height=100%;margin:0;padding:0&#x27;</span>)</span><br><span class="line">          canvas#<span class="title function_">resCanvas</span>(width=<span class="number">200</span>,style=<span class="string">&#x27;width=100%;height=100%;margin:0;padding:0;display:block&#x27;</span>)</span><br><span class="line">            != <span class="title function_">tagcloud</span>()</span><br><span class="line">          <span class="comment">//- 注释掉下面这些可以只保留标签云转动部分(不注释会展示静态标签)</span></span><br><span class="line">          <span class="comment">//- br</span></span><br><span class="line">          <span class="comment">//- != tagcloud(&#123;min_font: 16, max_font: 24, amount: 50, color: true, start_color: &#x27;#FF6600&#x27;, end_color: &#x27;#66FF99&#x27;&#125;)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><ul><li><strong>其中resCanvas的参数可以设置，tagcloud的字体大小颜色等参数也可以设置</strong></li></ul><h1 id="自定义功能"><a href="#自定义功能" class="headerlink" title="自定义功能"></a>自定义功能</h1><ul><li><strong>自定义功能需要配置一下 <strong>_config.yml</strong> 即可(自定义,不配置也行)</strong></li><li><strong>切记这个 _config.yml是根目录下的,然后添加如下代码:</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># hexo-tag-<span class="title function_">cloud</span>(自定义云标签)</span><br><span class="line"><span class="attr">tag_cloud</span>:</span><br><span class="line">    <span class="attr">textFont</span>: <span class="title class_">Trebuchet</span> <span class="variable constant_">MS</span>, <span class="title class_">Helvetica</span></span><br><span class="line">    <span class="attr">textColor</span>: <span class="string">&#x27;#333&#x27;</span></span><br><span class="line">    <span class="attr">textHeight</span>: <span class="number">25</span></span><br><span class="line">    <span class="attr">outlineColor</span>: <span class="string">&#x27;#E2E1D1&#x27;</span></span><br><span class="line">    <span class="attr">maxSpeed</span>: <span class="number">0.5</span></span><br><span class="line">    <span class="attr">pauseOnSelected</span>: <span class="literal">false</span> # <span class="literal">true</span> 意味着当选中对应 tag 时,停止转动</span><br></pre></td></tr></table></figure></li></ul><h3 id="然后使用-hexo-c-amp-amp-hexo-g-amp-amp-hexo-s-来享受属于你自己的独一无二的标签云吧。"><a href="#然后使用-hexo-c-amp-amp-hexo-g-amp-amp-hexo-s-来享受属于你自己的独一无二的标签云吧。" class="headerlink" title="然后使用 hexo c &amp;&amp; hexo g &amp;&amp; hexo s 来享受属于你自己的独一无二的标签云吧。"></a>然后使用 hexo c &amp;&amp; hexo g &amp;&amp; hexo s 来享受属于你自己的独一无二的标签云吧。</h3><h3 id="展示图如图所示"><a href="#展示图如图所示" class="headerlink" title="展示图如图所示:"></a>展示图如图所示:</h3><p><img src="/../upload/mogai/1.png" alt="image"></p><h1 id="实现不了功能"><a href="#实现不了功能" class="headerlink" title="实现不了功能"></a>实现不了功能</h1><ul><li><strong>在github上标签云使用教程中，按照步骤添加配置后不能添加标签云，后考虑解决方案如下：</strong></li><li><strong>可能是因为不能修改oackage.json文件</strong></li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h4><ul><li><strong>在根目录下的 package.json中使用命令安装:</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud@^2.1.* --save</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔改butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios学习笔记(3)-默认设置,create方法,拦截器与取消请求</title>
      <link href="/2022/07/25/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%E4%B8%8Ecreate%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/"/>
      <url>/2022/07/25/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%E4%B8%8Ecreate%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="1-axios的默认配置"><a href="#1-axios的默认配置" class="headerlink" title="1.axios的默认配置"></a>1.<strong>axios</strong>的默认配置</h1><ul><li><strong>在axios配置中存在baseUrl，header等配置，每次做的axios时，不一定所有的配置都要自己写，这时候要做一个默认值,如下:</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="comment">//默认配置(设置完默认设置后就不需要再axios函数里面设置了)</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">method</span> = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">params</span> = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;;<span class="comment">//设置url参数</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">3000</span>;<span class="comment">//设置超时时间</span></span><br><span class="line"></span><br><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">// 我们在这里就无需配置这些杂项了</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果-同样能接收和发送请求"><a href="#运行结果-同样能接收和发送请求" class="headerlink" title="运行结果:(同样能接收和发送请求)"></a>运行结果:(同样能接收和发送请求)</h3><p><img src="/../upload/axios/12.png" alt="image"><br><img src="/../upload/axios/13.png" alt="image"></p><h1 id="2-axios-的create方法-重要-常用"><a href="#2-axios-的create方法-重要-常用" class="headerlink" title="2.axios 的create方法(重要,常用)"></a>2.<strong>axios</strong> 的create方法(重要,常用)</h1><ul><li>**语法:**axios.create(config)</li><li><strong>1.根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置</strong></li><li><strong>2.新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的</strong></li></ul><h3 id="3-为什么要设计这个语法"><a href="#3-为什么要设计这个语法" class="headerlink" title="3.为什么要设计这个语法?"></a>3.为什么要设计这个语法?</h3><ul><li><strong>(1)需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理</strong></li><li><strong>(2)解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要求的接口请求中</strong></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h2><ul><li><strong>(用回上文提到的例子,此时这里已经设置了默认的全局配置,此时又有一个新的请求要指向另一台服务器,且请求方法是post,这时就能用到 <strong>axios的create()方法了</strong>)</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//切记使用create()方法创建新的axios需要写在默认设置的前面</span></span><br><span class="line"><span class="keyword">const</span> axios2 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="comment">// 要求:指向另一台服务器,请求方法为post</span></span><br><span class="line">    <span class="comment">// url为:http://abc/posts</span></span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">baseURL</span>:<span class="string">&#x27;http://abc&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="comment">//默认配置(设置完默认设置后就不需要再axios函数里面设置了)</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">method</span> = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">params</span> = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;;<span class="comment">//设置url参数</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">3000</span>;<span class="comment">//设置超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的按钮点击发送新的要求,这时这个axios封装的属性就不再是调用全局默认属性,而是使用create()方法创建出来的axios2了</span></span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">axios2</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-请求拦截器-axios-interceptors-request-use"><a href="#3-请求拦截器-axios-interceptors-request-use" class="headerlink" title="3.请求拦截器(axios.interceptors.request.use())"></a>3.请求拦截器(axios.interceptors.request.use())</h1><ul><li><strong>请求拦截器的本质是一个在真正发送请求前的函数（回调函数）</strong></li><li><strong>作用:对所用的请求做统一的处理:如追加请求头,追加参数,界面loading提示等..</strong></li><li><strong>请求拦截器相当于进地铁站过安检,接收axios的所有配置项,检查过后返回所有配置项</strong></li></ul><h3 id="练习demo"><a href="#练习demo" class="headerlink" title="练习demo"></a>练习demo</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器(axios.interceptors())</span></span><br><span class="line"><span class="comment">// 请求拦截器的本质是一个函数（回调函数）</span></span><br><span class="line"><span class="comment">// 请求拦截器相当于进地铁站过安检,接收axios的所有配置项,检查过后返回所有置项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器一般写在最前面(一般写法)</span></span><br><span class="line"><span class="comment">// 1.一般是用于token监测(token1是用户的凭据,通过获取token来查看你是否右相对应的权限)</span></span><br><span class="line"><span class="comment">// 2.一定要有返回值</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 比如这里我写一个demo要求当时间戳为偶数的时候,给响应头信息添加一个a=1属性</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() % <span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 潜规则变量名写config</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(config);</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册点击事件</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 点击向json-server服务器发送请求获取文章信息</span></span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/posts/1&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/axios/14.png" alt="image"></p><h3 id="多个请求拦截器存在的执行顺序问题-一般项目开发中用不到"><a href="#多个请求拦截器存在的执行顺序问题-一般项目开发中用不到" class="headerlink" title="多个请求拦截器存在的执行顺序问题(一般项目开发中用不到!)"></a>多个请求拦截器存在的执行顺序问题(一般项目开发中用不到!)</h3><ul><li><strong>就是:后指定的先执行!</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器1</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 比如这里我写一个demo要求当时间戳为偶数的时候,给响应头信息添加一个a=1属性</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() % <span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 潜规则变量名写config</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器1执行了&#x27;</span>,config);</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器2</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 比如这里我写一个demo要求当时间戳为偶数的时候,给响应头信息添加一个a=1属性</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() % <span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 潜规则变量名写config</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器2执行了&#x27;</span>,config);</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/../upload/axios/15.png" alt="image"></p><h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析:"></a>原理解析:</h3><ul><li><strong>从头到尾请求拦截器里面传的参数config都是一个东西,他没有变,因为是后指定的先执行,所以这个config在请求拦截器2中执行过后,又传递给了请求拦截器1再执行一遍而已!</strong></li></ul><h5 id="图解"><a href="#图解" class="headerlink" title="图解:"></a>图解:</h5><p><img src="/../upload/axios/16.png" alt="image"></p><h1 id="4-响应拦截器-axios-interceptors-response-use"><a href="#4-响应拦截器-axios-interceptors-response-use" class="headerlink" title="4.响应拦截器(axios.interceptors.response.use())"></a>4.响应拦截器(axios.interceptors.response.use())</h1><ul><li><strong>响应拦截器是得到响应后执行的一个回调函数(你得到一个响应,这个响应还没送到程序员手里,就已经调用了响应拦截器)</strong></li><li><strong>作用:</strong><ul><li><strong>若请求成功，对成功的数据进行处理，成功的回调函数, 传递的默认是 response</strong></li><li><strong>若请求失败，对失败进行下一步操作，失败的回调函数, 传递的默认是 error</strong></li></ul></li><li><strong>应用场景:</strong><ul><li><strong>一般直接在这里截获数据,然后直接将数据返回(response.data),那后面成功的回调接到的数据就是纯数据了</strong></li></ul></li></ul><h3 id="练习demo-1"><a href="#练习demo-1" class="headerlink" title="练习demo"></a>练习demo</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器(这里的请求拦截器什么也不走,就接收数据返回数据)</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器执行了&#x27;</span>,config);</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器(比请求拦截器应用得更广泛,项目开发没有不用相应拦截器的)</span></span><br><span class="line"><span class="comment">// 1.是什么?</span></span><br><span class="line">    <span class="comment">// 得到响应后执行的一个回调函数(你得到一个响应,这个响应还没送到程序员手里,就已经调用了响应拦截器)</span></span><br><span class="line"><span class="comment">// 2.作用：</span></span><br><span class="line">    <span class="comment">// 若请求成功，对成功的数据进行处理，成功的回调函数, 传递的默认是 response</span></span><br><span class="line">    <span class="comment">// 若请求失败，对失败进行下一步操作，失败的回调函数, 传递的默认是 error</span></span><br><span class="line"><span class="comment">// 3.应用场景:</span></span><br><span class="line">    <span class="comment">// 一般直接在这里截获数据,然后直接将数据返回(response.data),那后面成功的回调接到的数据就是纯数据了</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="comment">// 成功的回调</span></span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器成功的回调执行了!&#x27;</span>, response);</span><br><span class="line">        <span class="comment">// 响应拦截器成功的回调一定要有返回值</span></span><br><span class="line">        <span class="comment">// 比如我这里有一个要求:时间戳为偶数返回数据,时间戳为奇数不返回数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间戳为偶数,返回数据</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() % <span class="number">2</span> === <span class="number">0</span>) <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">        <span class="comment">// 时间戳为奇数不返回数据                      </span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&#x27;此时时间戳为奇数,不能给你返回数据!&#x27;</span>                     </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 失败的回调</span></span><br><span class="line">    <span class="comment">// axios认为状态码不是2开头的都是失败的请求</span></span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;相应拦截器失败的回调执行了&#x27;</span>, error);</span><br><span class="line">        <span class="comment">// 响应拦截器失败回调的返回值影响着后面走的成功的回调还是失败的回调</span></span><br><span class="line">        <span class="comment">// 这套规则与 .then方法 十分的相像(只要你返回的是非promise值,那么必定返回成功,返回的是promise值,就看当前这个promise的状态)</span></span><br><span class="line">        <span class="comment">// 如:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.返回的是 非Promise值</span></span><br><span class="line">        <span class="comment">// return 100 //最后走的是成功的回调:成功的回调最后返回的数据! 100</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.返回的是 Promise值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error) <span class="comment">//这回就走失败的回调了 :失败的回调返回的原因! AxiosError</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册点击事件</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 点击向json-server服务器发送请求获取文章信息</span></span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/posts/10&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的回调最后返回的数据!&#x27;</span>,response);</span><br><span class="line">    &#125;,<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的回调返回的原因!&#x27;</span>,error);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果:"></a>运行结果:</h3><ul><li><strong>一般返回成功</strong><br><img src="/../upload/axios/17.png" alt="image"></li><li><strong>应用场景:直接在响应拦截器中截取数据返回数据,最后在成功回调中返回的就是纯数据</strong><br><img src="/../upload/axios/18.png" alt="image"></li><li><strong>响应拦截器失败的回调返回的是非Promise值时返回的必定成功,最后走成功的回调返回值就是响应拦截器失败回调返回的值(你写入的非promise值)</strong><br><img src="/../upload/axios/19.png" alt="image"></li><li><strong>响应拦截器失败的回调返回的是Promise值时返回值看给Pormise状态,成功最后就走成功的回调,失败最后就走失败的回调,返回值就是resolve()或reject()里面传入的值</strong><br><img src="/../upload/axios/20.png" alt="image"></li></ul><h2 id="响应拦截器一般在项目开发中是用来截获数据-获取失败的-结合async和await来使用"><a href="#响应拦截器一般在项目开发中是用来截获数据-获取失败的-结合async和await来使用" class="headerlink" title="响应拦截器一般在项目开发中是用来截获数据,获取失败的!(结合async和await来使用)"></a>响应拦截器一般在项目开发中是用来截获数据,获取失败的!(结合async和await来使用)</h2><ul><li><strong>我们在项目开发中,使用响应来解其来获取失败,一般是这样做,在响应拦截器中统一处理失败,无需再在失败回调中处理了,代码如下所示:</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器(这里的请求拦截器什么也不做,就接收数据返回数据)</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器执行了&#x27;</span>,config);</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="comment">// 成功的回调</span></span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器成功的回调执行了!&#x27;</span>, response);</span><br><span class="line">        <span class="comment">// 响应拦截器成功的回调一定要有返回值</span></span><br><span class="line">        <span class="keyword">return</span> response.<span class="property">data</span>;                  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 失败的回调</span></span><br><span class="line">    <span class="comment">// axios认为状态码不是2开头的都是失败的请求</span></span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 项目中常用的处理失败</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器失败的回调执行了!&#x27;</span>);</span><br><span class="line">        <span class="title function_">alert</span>(error);</span><br><span class="line">        <span class="comment">// 这里返回一个pending(未完成)状态的Promise对象来中断Promise链,这样后面的回调就不用再写.then方法了!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目开发中的常用嵌套 async和await(只要成功的结果,失败的结果由相应器负责捕获和输出)</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> reslut = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/posts/10&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reslut);<span class="comment">//若是失败则不会输出结果,成功则只返回数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析:"></a>代码解析:</h3><ul><li><strong>这样写,最后的回调就只有成功的结果,失败的结果由响应拦截器负责截取和响应输出,后续我们不管有多少个响应拦截器,我们只需要await一等就完事了!</strong></li></ul><h1 id="5-取消请求"><a href="#5-取消请求" class="headerlink" title="5.取消请求"></a>5.取消请求</h1><ul><li><strong>文章篇幅过长,写在下一篇博客了-axios学习笔记(4)-取消请求,取消请求配合拦截器使用以及批量发送请求</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios学习笔记2-配置对象的详细说明以及axios的其他方式发送请求</title>
      <link href="/2022/07/25/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E4%BB%A5%E5%8F%8Aaxios%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/"/>
      <url>/2022/07/25/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E4%BB%A5%E5%8F%8Aaxios%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="1-配置对象的详细说明"><a href="#1-配置对象的详细说明" class="headerlink" title="1.配置对象的详细说明"></a>1.配置对象的详细说明</h1><ul><li><strong>什么是配置对象? config 就是配置对象</strong></li><li><ul><li><a href="https://github.com/axios/axios">官方文档</a>中提到:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Request</span> <span class="title class_">Config</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// url：指明请求去向</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// method：设置请求方法（get。post。put等..）</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//baseURL；设定url的基础结构，比如，我们在发送的时候写了好几次http://localhost:3000,这其实就是一个基础结构，这这时我们就可以将baseURL设置成这个值，然后在设置url的时候就子需要设置路径就可以了，axios内部会自动将baseURL和url做一个结合，想成最终的url结构（在项目中经常使用）</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//transformRequest: ：它可以对请求数据做一个处理，将处理完后的数据在向服务器发送</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want to transform the data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transformResponse（对响应进行预处理）:它可以对响应的结构做一些改变，改变完后，在用自定义的回调去处理这些结果</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want to transform the data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">//headers:设置头信息，在某些项目当中进行身份校验的时候，会要求你在头信息当中加入一些特殊的标识，然后来检验你的请求是否满足条件，这时就可以借助headers对请求头信息做一个控制</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//params: 这也是一个比较常用的参数，用来设定url参数的，比如我们要向服务端发送请求，在发送请求时需要在url后面传递参数如a=100&amp;b=200，这时我们就可以在params中添加参数，切记params是一个对象（对象添加参数的方法）</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//paramsSerializer:这是一个参数序列化的配置对象，作用是对请求的参数做一个序列化，转化成一个字符串,用得比较少</span></span><br><span class="line">  <span class="attr">paramsSerializer</span>: &#123;</span><br><span class="line">    <span class="attr">indexes</span>: <span class="literal">null</span> <span class="comment">// array indexes format (null - no brackets, false - empty brackets, true - brackets with indexes)</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//data:这是请求体设置，用的比较多，一般有两种形式可以设置，一种是对象形式，另一种是字符串形式，如果是对象形式，axios会将其转成一个json格式字符串进行传递；如果是字符串的话axios就直接传递，一般在形目中是看要求进行设置</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//timeout:超时时间，发送请求时，如果超过这个时间，这个请求就会取消，单位为ms</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//withCredentials:这个是在跨域请求时对cookie进行一个携带，false为不携带，如果是true的话，那么在跨域请求时可以讲cookie携带过去</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//adapter:可以对请求的识别器做一个设置，有两种，一种是发送ajax的，另一种是在node.js里面发送http请求的，两种不同的运行环境</span></span><br><span class="line">  <span class="attr">adapter</span>: <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//auth:对我们请求的基础做一个验证，可以在这里设置用户名和密码，用的相对性较少</span></span><br><span class="line">  <span class="attr">auth</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;janedoe&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;s00pers3cret&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//responseType:对响应体的结构做一个设置，默认值是一个json，即默认服务器返回的结果是一个json格式的</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//responseEncoding:响应结果的编码，一般默认是utf8</span></span><br><span class="line">  <span class="attr">responseEncoding</span>: <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//xsrfCookieName 和 srfHeaderName:域请求时对cookie的名字做一个设置，对请求头信息做一个设置。这是一个安全设置，保证了请求是来自于我们的客户端而不是来自于一些未知的网站页面，起一个保护作用，为什么够实现保护作用呢？服务器在返回结果时，会给我们返回一个唯一的标识，下次我们在发送请求时，会连同这个标识发送过去，服务器认了之后，检测没有问题，在给我们响应。有一些网站页面中当中会加入一些链接，向我们的服务器去发送请求，如果不做唯一的标识去检验的话，那么可能这个页面发送过来的请求就会直接对我们的结果产生影响，那加入这个参数后，我们的客户端请求，其他的页面就不能发送请求了（因为他没有这个标识），这时就可以有效避免这个跨站攻击了</span></span><br><span class="line">  <span class="attr">xsrfCookieName</span>: <span class="string">&#x27;XSRF-TOKEN&#x27;</span>,</span><br><span class="line">  <span class="attr">xsrfHeaderName</span>: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//onUploadProgress:上传时的回调</span></span><br><span class="line">  <span class="attr">onUploadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//onDownloadProgress:下载时的回调</span></span><br><span class="line">  <span class="attr">onDownloadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//maxContentLength:设置http响应体的最大尺寸,单位为字节</span></span><br><span class="line">  <span class="attr">maxContentLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//maxBodyLength:请求体的最大内容</span></span><br><span class="line">  <span class="attr">maxBodyLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//validateStatus:对响应结果的成功做一个设置（就是什么情况下认定它是成功的呢？）默认值为：响应代码大于等于200小于300</span></span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//maxRedirects:最大跳转次数，一般自能用于node.js种，前端的ajax用不到</span></span><br><span class="line">  <span class="attr">maxRedirects</span>: <span class="number">21</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//socketPath:设定socket文件位置，作用是向dock的守护进程去发送请求的，也就是作数据转发，这里有一个优先级关系，如果你设置了socket这个文件位置，也设置了代理（proxy），会优先使用socket这个文件的配置</span></span><br><span class="line">  <span class="attr">socketPath</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//httpAgent:对客户端的信息做一些配置，用的相对比较少</span></span><br><span class="line">  <span class="attr">httpAgent</span>: <span class="keyword">new</span> http.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">httpsAgent</span>: <span class="keyword">new</span> https.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">//proxy:设置我们的代理，这是一个非常有用的设置，是用在node.js服务端中的，一般在做爬虫的时候，你用一个ip去向目标服务器发送请求，抓取数据的话，很可能就会被别人进到你的ip，这时你就可以借助中间代理，疯狂的去切换，然后发送请求，就可以很好的获取别人服务器的数据,前端一般也用不到</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">protocol</span>: <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//proxy:设置我们的代理，这是一个非常有用的设置，是用在node.js服务端中的，一般在做爬虫的时候，你用一个ip去向目标服务器发送请求，抓取数据的话，很可能就会被别人进到你的ip，这时你就可以借助中间代理，疯狂的去切换，然后发送请求，就可以很好的获取别人服务器的数据</span></span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">cancel</span>) &#123;</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">//decompress:对响应结果做一个解压，只能用于node.js环境中设置，ajax不能进行设置</span></span><br><span class="line">  <span class="attr">decompress</span>: <span class="literal">true</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="2-axios的其他方式发送请求"><a href="#2-axios的其他方式发送请求" class="headerlink" title="2.axios的其他方式发送请求:"></a>2.axios的其他方式发送请求:</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(config): <span class="comment">//通用/最本质的发任意类型请求的方式</span></span><br><span class="line"><span class="title function_">axios</span>(url[, config]): <span class="comment">//可以只指定 url 发 get 请求</span></span><br><span class="line">axios.<span class="title function_">request</span>(config): <span class="comment">//等同于 axios(config) </span></span><br><span class="line">axios.<span class="title function_">get</span>(url[, config]): <span class="comment">//发 get 请求</span></span><br><span class="line">axios.<span class="title function_">delete</span>(url[, config]): <span class="comment">//发 delete 请求</span></span><br><span class="line">axios.<span class="title function_">post</span>(url[, data, config]): <span class="comment">//发 post 请求</span></span><br><span class="line">axios.<span class="title function_">put</span>(url[, data, config]): <span class="comment">//发 put 请求</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">xxx</span>: <span class="comment">//请求的默认全局配置</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(): <span class="comment">//添加请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(): <span class="comment">//添加响应拦截器</span></span><br><span class="line">axios.<span class="title function_">create</span>([config]): <span class="comment">//创建一个新的 axios(它没有下面的功能)</span></span><br><span class="line">axios.<span class="title class_">Cancel</span>(): <span class="comment">//用于创建取消请求的错误对象</span></span><br><span class="line">axios.<span class="title class_">CancelToken</span>(): <span class="comment">//用于创建取消请求的 token 对象</span></span><br><span class="line">axios.<span class="title function_">isCancel</span>(): <span class="comment">//是否是一个取消请求的错误</span></span><br><span class="line">axios.<span class="title function_">all</span>(promises): <span class="comment">//用于批量执行多个异步请求</span></span><br><span class="line">axios.<span class="title function_">spread</span>(): <span class="comment">//用来指定接收所有成功数据的回调函数的方法</span></span><br></pre></td></tr></table></figure><h2 id="这里只列举几样-其他的基本一致"><a href="#这里只列举几样-其他的基本一致" class="headerlink" title="这里只列举几样,其他的基本一致"></a>这里只列举几样,其他的基本一致</h2><h3 id="1-发送get请求-axios-get-这里用axios-request"><a href="#1-发送get请求-axios-get-这里用axios-request" class="headerlink" title="1).发送get请求(axios.get(),这里用axios.request())"></a>1).发送get请求(axios.get(),这里用axios.request())</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送 GET 请求</span></span><br><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// request方法与axios()方法使用一致</span></span><br><span class="line">    axios.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/comments&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-发送post请求-axios-post"><a href="#2-发送post请求-axios-post" class="headerlink" title="2).发送post请求(axios.post())"></a>2).发送post请求(axios.post())</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送 POST 请求(与GET,PUT,Delet基本一致,参考基本使用)</span></span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// axios()</span></span><br><span class="line">    axios.<span class="title function_">post</span>(</span><br><span class="line">        <span class="string">&#x27;http://localhost:3000/comments&#x27;</span>, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;body&quot;</span>: <span class="string">&quot;happy!&quot;</span>,</span><br><span class="line">            <span class="string">&quot;postId&quot;</span>: <span class="number">2</span></span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// axios会自动将服务器返回结果进行jason解析,即将响应体转象返回</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios学习笔记(1)-axios初识以及基本使用</title>
      <link href="/2022/07/25/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-axios%E5%88%9D%E8%AF%86/"/>
      <url>/2022/07/25/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-axios%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是-axios"><a href="#1-什么是-axios" class="headerlink" title="1.什么是 axios ?"></a>1.什么是 <strong>axios</strong> ?</h1><ul><li><strong>Axios 是一个基于 Promise 的 http客户端，可以在浏览器，node.Js中去运行,浏览器可以借助 axios 向服务端发送 ajax 请求,同样可以在node.js中发送http请求</strong></li><li><strong>它前端最流行的 ajax 请求库</strong></li><li><strong>react&#x2F;vue 官方都推荐使用 axios 发 ajax 请求</strong></li><li><a href="https://github.com/axios/axios">官方文档</a></li></ul><h1 id="2-axios-的特点"><a href="#2-axios-的特点" class="headerlink" title="2.axios 的特点"></a>2.<strong>axios</strong> 的特点</h1><ol><li><strong>基于 xhr + promise 的异步 ajax 请求库</strong></li><li><strong>浏览器端&#x2F;node 端都可以使用</strong></li><li><strong>支持请求／响应拦截器</strong></li><li><strong>支持请求取消</strong></li><li><strong>请求&#x2F;响应数据转换</strong></li><li><strong>批量发送多个请求</strong></li></ol><h1 id="3-axios-常用语法-返回一个Promise对象"><a href="#3-axios-常用语法-返回一个Promise对象" class="headerlink" title="3.axios 常用语法(返回一个Promise对象)"></a>3.<strong>axios</strong> 常用语法(返回一个Promise对象)</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(config): <span class="comment">//通用/最本质的发任意类型请求的方式</span></span><br><span class="line"><span class="title function_">axios</span>(url[, config]): <span class="comment">//可以只指定 url 发 get 请求</span></span><br><span class="line">axios.<span class="title function_">request</span>(config): <span class="comment">//等同于 axios(config) </span></span><br><span class="line">axios.<span class="title function_">get</span>(url[, config]): <span class="comment">//发 get 请求</span></span><br><span class="line">axios.<span class="title function_">delete</span>(url[, config]): <span class="comment">//发 delete 请求</span></span><br><span class="line">axios.<span class="title function_">post</span>(url[, data, config]): <span class="comment">//发 post 请求</span></span><br><span class="line">axios.<span class="title function_">put</span>(url[, data, config]): <span class="comment">//发 put 请求</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">xxx</span>: <span class="comment">//请求的默认全局配置</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(): <span class="comment">//添加请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(): <span class="comment">//添加响应拦截器</span></span><br><span class="line">axios.<span class="title function_">create</span>([config]): <span class="comment">//创建一个新的 axios(它没有下面的功能)</span></span><br><span class="line">axios.<span class="title class_">Cancel</span>(): <span class="comment">//用于创建取消请求的错误对象</span></span><br><span class="line">axios.<span class="title class_">CancelToken</span>(): <span class="comment">//用于创建取消请求的 token 对象</span></span><br><span class="line">axios.<span class="title function_">isCancel</span>(): <span class="comment">//是否是一个取消请求的错误</span></span><br><span class="line">axios.<span class="title function_">all</span>(promises): <span class="comment">//用于批量执行多个异步请求</span></span><br><span class="line">axios.<span class="title function_">spread</span>(): <span class="comment">//用来指定接收所有成功数据的回调函数的方法</span></span><br></pre></td></tr></table></figure><p><img src="/../upload/axios/1.png" alt="image"></p><h1 id="4-axios-的基本使用"><a href="#4-axios-的基本使用" class="headerlink" title="4.axios 的基本使用:"></a>4.<strong>axios</strong> 的基本使用:</h1><ul><li><strong>这里我用一个demo来演示axios的基本使用,要求如下:用json-server来充当http服务器,页面当中有4个按钮,分别对应 GET、POST、PUT、delete请求,json-server服务器当中有post页面里面存放的是一些数据,每个数据有对应的id号,按下相应的按钮来向服务器发送请求,服务器相应结果!</strong></li></ul><h2 id="demo页面显示如下"><a href="#demo页面显示如下" class="headerlink" title="demo页面显示如下:"></a>demo页面显示如下:</h2><p><img src="/../upload/axios/2.png" alt="image"></p><h2 id="json-server服务器内部如下"><a href="#json-server服务器内部如下" class="headerlink" title="json-server服务器内部如下:"></a>json-server服务器内部如下:</h2><p><img src="/../upload/axios/3.png" alt="image"></p><h3 id="1-发送get请求"><a href="#1-发送get请求" class="headerlink" title="1).发送get请求:"></a>1).发送get请求:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复习常用的ajax请求方法:</span></span><br><span class="line">    <span class="comment">// 1.get:获取数据(只读不写)</span></span><br><span class="line">    <span class="comment">// 2.post:新增数据(可读可写)</span></span><br><span class="line">    <span class="comment">// 3.put:更新数据</span></span><br><span class="line">    <span class="comment">// 4.delete:删除数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">var</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line"><span class="comment">// 1.GET(获取某一篇文章)</span></span><br><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 发送ajax请求</span></span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">// 请求类型</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="comment">// URL(获取第二篇文章)</span></span><br><span class="line">        <span class="attr">url</span>:<span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>,</span><br><span class="line">        <span class="comment">// 其他设置(url参数,请求头信息等..)</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果如下-成功读取到数据"><a href="#运行结果如下-成功读取到数据" class="headerlink" title="运行结果如下:(成功读取到数据)"></a>运行结果如下:(成功读取到数据)</h3><p><img src="/../upload/axios/4.png" alt="image"></p><h3 id="2-发送post请求"><a href="#2-发送post请求" class="headerlink" title="2).发送post请求:"></a>2).发送post请求:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.POST(新增某一篇文章)</span></span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 发送ajax请求</span></span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">// 请求类型</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="comment">// URL(这里不用写指定id好,只需要写文件夹名即可)</span></span><br><span class="line">        <span class="attr">url</span>:<span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">        <span class="comment">// 其他设置(url参数,请求头信息等..)</span></span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">            <span class="attr">title</span>:<span class="string">&#x27;hi!&#x27;</span>,</span><br><span class="line">            <span class="attr">author</span>:<span class="string">&#x27;jo&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果如下-成功添加数据"><a href="#运行结果如下-成功添加数据" class="headerlink" title="运行结果如下:(成功添加数据)"></a>运行结果如下:(成功添加数据)</h3><p><img src="/../upload/axios/5.png" alt="image"></p><h3 id="服务器内新增-id为3-的文章"><a href="#服务器内新增-id为3-的文章" class="headerlink" title="服务器内新增 id为3 的文章"></a>服务器内新增 id为3 的文章</h3><p><img src="/../upload/axios/6.png" alt="image"></p><h3 id="3-发送put请求"><a href="#3-发送put请求" class="headerlink" title="3).发送put请求:"></a>3).发送put请求:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.PUT(更新某一篇文章)</span></span><br><span class="line">btns[<span class="number">2</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 发送ajax请求</span></span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">// 请求类型</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">        <span class="comment">// URL(PUT更新需要指定更新文章,即这里需要加文章的id号)</span></span><br><span class="line">        <span class="attr">url</span>:<span class="string">&#x27;http://localhost:3000/posts/3&#x27;</span>,</span><br><span class="line">        <span class="comment">// 其他设置(url参数,请求头信息等..)</span></span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">            <span class="attr">title</span>:<span class="string">&#x27;hi!&#x27;</span>,</span><br><span class="line">            <span class="attr">author</span>:<span class="string">&#x27;tom&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果如下-成功更新-更改-数据"><a href="#运行结果如下-成功更新-更改-数据" class="headerlink" title="运行结果如下:(成功更新(更改)数据)"></a>运行结果如下:(成功更新(更改)数据)</h3><p><img src="/../upload/axios/7.png" alt="image"></p><h3 id="服务器内新增-id为3-的文章的作者变为tom"><a href="#服务器内新增-id为3-的文章的作者变为tom" class="headerlink" title="服务器内新增 id为3 的文章的作者变为tom"></a>服务器内新增 id为3 的文章的作者变为tom</h3><p><img src="/../upload/axios/8.png" alt="image"></p><h3 id="3-发送delete请求"><a href="#3-发送delete请求" class="headerlink" title="3).发送delete请求:"></a>3).发送delete请求:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.delete(删除某一篇文章)</span></span><br><span class="line">btns[<span class="number">3</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 发送ajax请求</span></span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">// 请求类型</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;delete&#x27;</span>,</span><br><span class="line">        <span class="comment">// URL(PUT更新需要指定删除文章,即这里需要加文章的id号)</span></span><br><span class="line">        <span class="attr">url</span>:<span class="string">&#x27;http://localhost:3000/posts/3&#x27;</span>,</span><br><span class="line">        <span class="comment">// 其他设置(url参数,请求头信息等..)</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果如下-成功删除数据"><a href="#运行结果如下-成功删除数据" class="headerlink" title="运行结果如下:(成功删除数据)"></a>运行结果如下:(成功删除数据)</h3><p><img src="/../upload/axios/9.png" alt="image"></p><h3 id="服务器内删除掉了-id为3-的文章"><a href="#服务器内删除掉了-id为3-的文章" class="headerlink" title="服务器内删除掉了 id为3 的文章"></a>服务器内删除掉了 id为3 的文章</h3><p><img src="/../upload/axios/10.png" alt="image"></p><h1 id="5-返回结果的解析"><a href="#5-返回结果的解析" class="headerlink" title="5.返回结果的解析"></a>5.返回结果的解析</h1><p><img src="/../upload/axios/11.png" alt="image"></p><ul><li><strong>config：配置对象，里面包含请求类型（method），请求url，请求体等。</strong></li><li><strong>data：响应体的结果，服务器返回的结果，它是一个对象，因为axios会自动将服务器返回结果进行jason解析,即将响应体转成对象返回</strong></li><li><strong>headers：响应头信息.</strong></li><li><strong>request：原生的ajax请求对象，我们都知道axios是用来发送ajax请求的，而发送ajax请求就必须用到底层的XMLHttpRequest的实例对象，而这里的requset这个属性保存的就是当前axios在发送请求时所创建的ajax请求对象，也就是XMLHttpRequest的实例对象</strong></li><li><strong>status：响应状态码</strong></li><li><strong>statusText：响应状态字符串</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise拓展-async和await</title>
      <link href="/2022/07/23/Promise%E6%8B%93%E5%B1%95-async%E5%92%8Cawait/"/>
      <url>/2022/07/23/Promise%E6%8B%93%E5%B1%95-async%E5%92%8Cawait/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是-async-其实就跟then方法是基本一致的"><a href="#1-什么是-async-其实就跟then方法是基本一致的" class="headerlink" title="1.什么是 async(其实就跟then方法是基本一致的)"></a>1.什么是 <strong>async(其实就跟then方法是基本一致的)</strong></h1><p>  <strong>async 顾名思义就是异步的意思,它是ES2017标准中引入的一种新函数,它是Generator函数的语法糖,它是作用是简化异步操作,使得异步操作更加简单</strong></p><ul><li><strong>async函数的返回值为 promise 对象</strong></li><li><strong>promise 对象的结果由 async 函数执行的返回值决定</strong>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//几乎跟then方法是一模一样</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1. 如果返回值是一个非Promise类型的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//2. 如果返回的是一个Promise对象(返回的是resolve类型)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//3. 如果返回的是一个Promise对象(返回的是reject类型)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main4</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//4. 抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Oh NO&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">main1</span>());<span class="comment">//Promise &#123;&lt;fulfilled&gt;: &#x27;hello!&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">main2</span>());<span class="comment">//返回结果:状态为fulfilled的promise对象,返回值为OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">main3</span>());<span class="comment">//返回结果:状态为rejected的promise对象,返回值为Oh No</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">main4</span>());<span class="comment">//Promise &#123;&lt;rejected&gt;: &#x27;Oh NO&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下:"></a>结果如下:</h4><p><img src="/../upload/promise/async/1.png" alt="image"></p><h1 id="2-什么是-await"><a href="#2-什么是-await" class="headerlink" title="2.什么是 await ?"></a>2.什么是 <strong>await</strong> ?</h1><p> <strong>await顾名思义就是等待,它同样是ES2017中新引入的一种新表达式,用于嵌套async来使用,解决异步操作</strong></p><ul><li><strong>await 右侧的表达式一般为 promise 对象, 但也可以是其它的值(数字,字符串,布尔类型等,运算也可以)</strong></li><li><strong>如果表达式是 promise 对象, await 返回的是 promise 成功的值(切记是成功的值)</strong></li><li><strong>如果表达式是其它值, 直接将此值作为 await 的返回值(即右侧是什么我就返回什么)</strong></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><ul><li><strong>1.await 必须写在 async 函数中, 但 async 函数中可以没有 await(就好比单相思)</strong></li><li><strong>2.如果 await 的 promise 失败了, 就会抛出异常, 则需要通过 try…catch 捕获处理</strong></li></ul><h3 id="普及一下try-catch语法"><a href="#普及一下try-catch语法" class="headerlink" title="普及一下try-catch语法:"></a>普及一下try-catch语法:</h3><ul><li><strong>try catch语句是JavaScript中一种处理异常的标准方式</strong>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//可能会导致错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="title function_">e</span>(error的缩写)) &#123;</span><br><span class="line">    <span class="comment">//在错误发生时该如何进行处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="await-的使用demo"><a href="#await-的使用demo" class="headerlink" title="await 的使用demo"></a><strong>await</strong> 的使用demo</h3>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//1. 右侧为promise的情况 await会返回Promise对象为成功状态时的值</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> p;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//2. 右侧为其他类型的数据,直接返回右侧变量值(即右侧是什么,我就给你返回什么)</span></span><br><span class="line">    <span class="comment">// 一般这种情况很少见,多数情况是 Promise对象</span></span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">await</span> <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&#x27;Eorr&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//3. 如果promise是失败的状态就会抛出一个错误,这时我们就需要用try-catch来捕获处理这个错误</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res3 = <span class="keyword">await</span> p;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="comment">// 在这里获取失败的结果</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main1</span>();<span class="comment">//结果为:OK</span></span><br><span class="line"><span class="title function_">main2</span>();<span class="comment">//结果为:20</span></span><br><span class="line"><span class="title function_">main3</span>();<span class="comment">//结果为:Eorr</span></span><br></pre></td></tr></table></figure><h4 id="结果如下-1"><a href="#结果如下-1" class="headerlink" title="结果如下:"></a>结果如下:</h4><p><img src="/../upload/promise/async/2.png" alt="image"></p><h1 id="3-util-promisify-函数用法的讲解"><a href="#3-util-promisify-函数用法的讲解" class="headerlink" title="3.util.promisify 函数用法的讲解"></a>3.<strong>util.promisify</strong> 函数用法的讲解</h1><h2 id="什么是-util-promisify"><a href="#什么是-util-promisify" class="headerlink" title="什么是 util.promisify?"></a><strong>什么是 util.promisify?</strong></h2><ul><li><strong>util.promisify是在node.js 8.x版本中新增的一个工具，用于将老式的Error first callback转换为Promise对象，让老项目改造变得更为轻松。</strong></li><li><strong>首先要解释一下这种工具大致的实现思路，因为在Node中异步回调有一个约定：Error first，也就是说回调函数中的第一个参数一定要是Error对象，其余参数才是正确时的数据。</strong></li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><ul><li><strong>传入一个错误优先的回调风格的函数(即形参要求错误优先(err,value)),返回一个promise版本</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入 util 模块</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//返回一个新的函数</span></span><br><span class="line"><span class="comment">// fs.readFile就是一个错误优先的函数方法(readFile(&#x27;path&#x27;,(err,data)=&gt;&#123;&#125;))</span></span><br><span class="line"><span class="keyword">let</span> mineReadFile = util.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接读取Promise对象里面的value值</span></span><br><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/content.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());<span class="comment">//转换buffer</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="结果如下-2"><a href="#结果如下-2" class="headerlink" title="结果如下:"></a>结果如下:</h4><p><img src="/../upload/promise/async/3.png" alt="image"></p><h1 id="async和await两者的结合使用大大方便了我们的开发-案例"><a href="#async和await两者的结合使用大大方便了我们的开发-案例" class="headerlink" title="async和await两者的结合使用大大方便了我们的开发(案例)"></a><strong>async和await</strong>两者的结合使用大大方便了我们的开发(案例)</h1><ul><li><strong>案例要求:读取resolve文件夹下面的三个文件:1.html 2.html和3.html</strong></li></ul><h2 id="第一种方式-使用回调函数"><a href="#第一种方式-使用回调函数" class="headerlink" title="第一种方式:使用回调函数"></a>第一种方式:使用回调函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回调函数的方式(存在回调地狱,存在错误要每一层去做if-else判断,非常麻烦)</span></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/1.html&#x27;</span>, <span class="function">(<span class="params">err, data1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/2.html&#x27;</span>, <span class="function">(<span class="params">err, data2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/3.html&#x27;</span>, <span class="function">(<span class="params">err, data3</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data1 + data2 + data3);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="第二种方式-async嵌套await"><a href="#第二种方式-async嵌套await" class="headerlink" title="第二种方式:async嵌套await"></a>第二种方式:async嵌套await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有回调地狱,并且整体简洁高效</span></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> mineReadFile = util.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//读取第文件的内容</span></span><br><span class="line">        <span class="keyword">let</span> data1 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/1.html&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> data2 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/2.html&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> data3 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/3.html&#x27;</span>);</span><br><span class="line">        <span class="comment">// 没有错误则输出,有错误则抛出错误让下层的catch捕获</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data1 + data2 + data3);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="comment">// 输出错误信息</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure><h4 id="结果如下-两者均一致"><a href="#结果如下-两者均一致" class="headerlink" title="结果如下(两者均一致):"></a>结果如下(两者均一致):</h4><p><img src="/../upload/promise/async/4.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> Promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改butterfly(3)-给博客添加侧边栏电子时钟</title>
      <link href="/2022/07/23/%E9%AD%94%E6%94%B9butterfly3/"/>
      <url>/2022/07/23/%E9%AD%94%E6%94%B9butterfly3/</url>
      
        <content type="html"><![CDATA[<h1 id="魔改butterfly主题3-给博客添加侧边栏电子时钟"><a href="#魔改butterfly主题3-给博客添加侧边栏电子时钟" class="headerlink" title="魔改butterfly主题3-给博客添加侧边栏电子时钟"></a>魔改butterfly主题3-给博客添加侧边栏电子时钟</h1><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤:"></a>实现步骤:</h3><ul><li><strong>安装必要依赖,在你的博客所在的根目录下,打开cmd命令窗口执行以下命令:</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-butterfly-clock --save </span><br></pre></td></tr></table></figure></li><li><strong>在站点配置文件 _config.yml(是在themes &gt; butterfly目录下的) 添加配置项：</strong><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># electric_clock</span></span><br><span class="line"><span class="attr">electric_clock:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="comment"># - /posts/</span></span><br><span class="line">    <span class="comment"># - /about/</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sticky_layout</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">loading:</span>   <span class="comment">#加载动画自定义 </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="如图所示"><a href="#如图所示" class="headerlink" title="如图所示:"></a>如图所示:</h4><p><img src="/../upload/mogai3/1.png" alt="image"></p><h2 id="最终效果如图所示"><a href="#最终效果如图所示" class="headerlink" title="最终效果如图所示:"></a>最终效果如图所示:</h2><p><img src="/../upload/mogai3/2.png" alt="image"></p><blockquote><p>这篇博客引用了作者为”<strong>唐志远</strong>“的文章<br>原文链接为:<a href="https://tzy1997.com/articles/hexo1606/#%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%94%B5%E5%AD%90%E6%97%B6%E9%92%9F">唐志远的博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔改butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise中的关键问题</title>
      <link href="/2022/07/23/Promise%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/23/Promise%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-一个-Promise-指定多个成功-x2F-失败回调函数-都会调用吗"><a href="#1-一个-Promise-指定多个成功-x2F-失败回调函数-都会调用吗" class="headerlink" title="1.一个 Promise 指定多个成功&#x2F;失败回调函数, 都会调用吗?"></a>1.一个 Promise 指定多个成功&#x2F;失败回调函数, 都会调用吗?</h1><ul><li><strong>答案是肯定的,当 promise 改变为对应状态时都会调用</strong></li></ul><h1 id="2-改变-promise-状态和指定回调函数谁先谁后"><a href="#2-改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="2.改变 promise 状态和指定回调函数谁先谁后?"></a>2.改变 promise 状态和指定回调函数谁先谁后?</h1><ul><li><strong>(1)都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</strong></li><li><strong>(2)如何先改状态再指定回调?</strong><ul><li><strong>① 在执行器中直接调用 resolve()&#x2F;reject()</strong></li><li><strong>② 延迟更长时间才调用 then()</strong></li></ul></li><li><strong>(3)什么时候才能得到数据?</strong><ul><li><strong>① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</strong></li><li><strong>② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</strong></li></ul></li></ul><h1 id="3-Promise-then-返回的新-Promise-的结果状态由什么决定"><a href="#3-Promise-then-返回的新-Promise-的结果状态由什么决定" class="headerlink" title="3.Promise.then()返回的新 Promise 的结果状态由什么决定?"></a>3.Promise.then()返回的新 Promise 的结果状态由什么决定?</h1><ul><li><strong>(1)简单表达: 由 then()指定的回调函数执行的结果决定</strong></li><li><strong>(2)详细表达:</strong><ul><li><strong>① 如果抛出异常, 新 promise 变为rejected, reason 为抛出的异常</strong></li><li><strong>② 如果返回的是非 promise 的任意值, 新 promise 变为resolved, value 为返回的值</strong></li><li><strong>③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</strong></li></ul></li></ul><h1 id="4-Promise中的异常穿透特性"><a href="#4-Promise中的异常穿透特性" class="headerlink" title="4.Promise中的异常穿透特性"></a>4.Promise中的异常穿透特性</h1><ul><li><strong>(1)当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</strong></li><li><strong>(2)前面任何操作出了异常, 都会传到最后失败的回调中处理</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">                <span class="comment">// reject(&#x27;Err&#x27;);</span></span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(111);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&#x27;失败啦!&#x27;</span>;</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);<span class="comment">//可以在最后的catch环节捕获第一层的错误</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/key-question/1.png" alt="image"></p><h3 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明:"></a>解释说明:</h3><ul><li><strong>promise的链式调用中存在一种异常穿透的特性,就是我们可以在链式作用的最后加上一个catch方法来捕获整个链式调用过程中的错误,无需在链式调用的每一个环节参加catch方法来捕获错误</strong></li></ul><h1 id="5-中断-Promise-的链式调用"><a href="#5-中断-Promise-的链式调用" class="headerlink" title="5.中断 Promise 的链式调用?"></a>5.中断 Promise 的链式调用?</h1><ul><li><strong>(1)当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</strong></li><li><strong>(2)办法: 在回调函数中返回一个 pendding 状态的 promise 对象</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">            <span class="comment">//有且只有一个方式:那就是返回一个pending状态的Promise对象,才能中断Promise1链条</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 输出结果只有111,无222,333</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="结果如下-1"><a href="#结果如下-1" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/key-question/2.png" alt="image"></p><h3 id="解释说明-1"><a href="#解释说明-1" class="headerlink" title="解释说明:"></a>解释说明:</h3><ul><li><strong>中断Promise链式调用的方法有且只有一种:那就是在你想要中断的环节当中添加一个pending状态的Promise对象返回值</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> Promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise中的常用API</title>
      <link href="/2022/07/23/Promise%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8API/"/>
      <url>/2022/07/23/Promise%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise中的常用API"><a href="#Promise中的常用API" class="headerlink" title="Promise中的常用API"></a><strong>Promise</strong>中的常用API</h1><h2 id="1-Promise中的构造函数-Promise-excutor"><a href="#1-Promise中的构造函数-Promise-excutor" class="headerlink" title="1.Promise中的构造函数 : Promise (excutor) {}"></a>1.Promise中的构造函数 : Promise (excutor) {}</h2><ul><li><strong>(1)executor 函数:执行器 (resolve, reject) &#x3D;&gt; {}</strong></li><li><strong>(2)resolve 函数: 内部定义成功时我们调用的函数 value &#x3D;&gt; {}</strong></li><li><strong>(3)reject 函数: 内部定义失败时我们调用的函数 reason &#x3D;&gt; {}</strong></li></ul><p> <strong>说明:</strong> executor 会在 Promise 内部<strong>立即同步调用</strong>,异步操作在执行器中执行</p><h4 id="函数解析"><a href="#函数解析" class="headerlink" title="函数解析:"></a>函数解析:</h4><p>我们可以通过 new Promise 来实例化对象,在new的时候,实例化需要接收一个参数,这个参数是一个函数类型的参数(可为箭头函数,也可为匿名函数),这个函数当中有两个形参:<strong>resolve</strong> 和 <strong>reject</strong> ,这两个形参也是一个函数,是Promise内部定义的,当Promise内异步任务为成功是就调用resolve,失败则调用reject</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1) 创建 promise 对象(pending 状态), 指定执行器函数</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2) 在执行器函数中启动异步任务</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">            <span class="comment">// 3) 根据结果做不同处理</span></span><br><span class="line">            <span class="comment">// 3.1) 如果成功了, 调用 resolve(), 指定成功的 value, 变为 resolved 状态</span></span><br><span class="line">            <span class="keyword">if</span> (time%<span class="number">2</span>===<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="string">&#x27;成功的值 &#x27;</span>+ time)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3.2) 如果失败了, 调用 reject(), 指定失败的 reason, 变为rejected 状态</span></span><br><span class="line">                    <span class="title function_">reject</span>(<span class="string">&#x27;失败的值&#x27;</span> + time)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-Promise-prototype-then-方法-onResolved-onRejected-x3D-gt"><a href="#2-Promise-prototype-then-方法-onResolved-onRejected-x3D-gt" class="headerlink" title="2.Promise.prototype.then 方法: (onResolved, onRejected) &#x3D;&gt; {}"></a>2.Promise.prototype.then 方法: (onResolved, onRejected) &#x3D;&gt; {}</h2><ul><li><strong>(1)onResolved 函数: 成功的回调函数 (value) &#x3D;&gt; {}</strong></li><li><strong>(2)onRejected 函数: 失败的回调函数 (reason) &#x3D;&gt; {}</strong><br><strong>说明:</strong> 指定用于得到<strong>成功 value 的成功回调</strong>和用于得到<strong>失败 reason 的失败回调</strong>返回一个<strong>新的 promise 对象</strong></li></ul><h4 id="函数解析-1"><a href="#函数解析-1" class="headerlink" title="函数解析:"></a>函数解析:</h4><p>then方法是用来指定回调的,里面传递<strong>两个函数类型(一般用箭头函数形式)的参数</strong>(onResolved,onRejected),<strong>成功执行第一个(onResolved)函数,失败执行第二个函数(onRejected)</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//能 promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason </span></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// 成功的回调函数 onResolved, 得到成功的 vlaue </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的 value: &#x27;</span>, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="comment">// 失败的回调函数 onRejected, 得到失败的 reason </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的 reason: &#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="3-Promise-prototype-catch-方法-onRejected-x3D-gt"><a href="#3-Promise-prototype-catch-方法-onRejected-x3D-gt" class="headerlink" title="3.Promise.prototype.catch 方法: (onRejected) &#x3D;&gt; {}"></a>3.Promise.prototype.catch 方法: (onRejected) &#x3D;&gt; {}</h2><ul><li><strong>用法与then想象,但是它只能用于指定失败的回调函数,不能用于指定成功的回调函数</strong><br> <strong>说明:</strong> then()的语法糖,  相当于: <strong>then(undefined, onRejected)</strong></li></ul><h4 id="函数解析-2"><a href="#函数解析-2" class="headerlink" title="函数解析:"></a>函数解析:</h4><p> <strong>catch</strong>方法其实就是用<strong>then</strong>做的一个单独独立的封装,它内部的实现原理就是用<strong>then方法</strong>单独指向<strong>reject状态</strong>而已<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//修改 promise 对象的状态</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行 catch 方法</span></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/API/1.png" alt="image"></p><h2 id="4-Promise-resolve-方法-value-x3D-gt"><a href="#4-Promise-resolve-方法-value-x3D-gt" class="headerlink" title="4.Promise.resolve 方法: (value) &#x3D;&gt; {}"></a>4.Promise.resolve 方法: (value) &#x3D;&gt; {}</h2><ul><li><strong>(1)value: 成功的数据或 promise 对象</strong><br> <strong>说明:</strong> 返回一个成功&#x2F;失败的 <strong>promise 对象</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.传入非Promise类型对象,返回必然成功Promise对象</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="comment">//2.如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果</span></span><br><span class="line">    <span class="comment">// 1).传入为reject类型的promise对象</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;OK&#x27;);</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line">    <span class="comment">// 2).传入为resolve类型的promise对象</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    <span class="comment">// reject(&#x27;Error&#x27;);</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);<span class="comment">//结果为:Promise &#123;&lt;fulfilled&gt;: &#x27;hello&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//结果为:Promise &#123;&lt;rejected&gt;: &#x27;Error&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);<span class="comment">//结果为:Promise &#123;&lt;fulfilled&gt;: &#x27;OK&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数解析-3"><a href="#函数解析-3" class="headerlink" title="函数解析:"></a>函数解析:</h4><p>相较于then和catch来说它有些不一样,resolve是属于Promise这个函数对象的,并不属于实例对象,作用是接收一个参数,返回一个成功或失败的Promise对象,其实它就是为了能够快速获得一个对象并且能够封装一个值,将这个值转化为一个Promise对象.</p><ul><li>如若传入的参数为 <strong>非Promise类型的对象</strong> ,<strong>返回的结果必然为成功的Peomise对象</strong>,返回值为你<strong>resolve()括号中的数值</strong></li><li>如若传入的参数为 <strong>Promise类型的对象</strong>,<strong>返回的结果则根据你传入的Promise的结果,如果你传入的是reject类型的Promise,这返回的就是reject,返回值为你reject()括号内的值,若为resolve也是类似</strong></li></ul><h4 id="结果如下-1"><a href="#结果如下-1" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/API/2.png" alt="image"></p><h2 id="5-Promise-reject-方法-reason-x3D-gt"><a href="#5-Promise-reject-方法-reason-x3D-gt" class="headerlink" title="5.Promise.reject 方法: (reason) &#x3D;&gt; {}"></a>5.Promise.reject 方法: (reason) &#x3D;&gt; {}</h2><ul><li><strong>(1)reason: 失败的原因</strong><br> <strong>说明:</strong> 只返回一个失败的 <strong>promise 对象</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);<span class="comment">//结果为:Promise &#123;&lt;rejected&gt;: &#x27;hello!&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);<span class="comment">//结果为:Promise &#123;&lt;rejected&gt;: Promise&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//结果为:Promise &#123;&lt;rejected&gt;: Promise&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数解析-4"><a href="#函数解析-4" class="headerlink" title="函数解析:"></a>函数解析:</h4><p>与resolve一样均是属于Promise这个函数对象的,并不属于实例对象,作用是接收一个参数,返回一个必然失败的Promise对象,其实它就是为了能够快速获得一个失败对象,将这个值转化为一个Promise对象.</p><ul><li>如若传入的参数为 <strong>非Promise类型的对象</strong> ,<strong>返回的结果必然为失败的Peomise对象</strong>,返回值为你<strong>reject()括号中的数值</strong></li><li>如若传入的参数为 <strong>Promise类型的对象</strong>,<strong>同返回一个必然失败的Promise对象,即便你传入的是resolve的Promise对象,返回的还是失败的Promise对象,但是返回的值就不是resolve()括号里面的值了,而是整一个对象,就是如果你给reject()里面传入一个resolve类型的Promise对象,返回的是一个失败的对象,返回值是整一个你传入的resolve类型Promise对象(即你传入什么Promise对象,就返回什么Promise对象)</strong></li></ul><h4 id="结果如下-2"><a href="#结果如下-2" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/API/3.png" alt="image"></p><h2 id="6-Promise-all-方法-promises-x3D-gt"><a href="#6-Promise-all-方法-promises-x3D-gt" class="headerlink" title="6.Promise.all 方法: (promises) &#x3D;&gt; {}"></a>6.Promise.all 方法: (promises) &#x3D;&gt; {}</h2><ul><li><strong>(1)promises: 包含 n 个 promise 的数组</strong><br> <strong>说明:</strong> 返回一个<strong>新的 promise</strong>, 只有<strong>所有</strong>的 promise 都成功才成功, <strong>只要有一个失败了就直接失败(相当于我们”与”,全真为真,一个假则为假)</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);<span class="comment">//全为成功,返回为fulfilled</span></span><br><span class="line"><span class="keyword">const</span> r2 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p4]);<span class="comment">//有一个失败,返回rejecte</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1);<span class="comment">//resolved</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2);<span class="comment">//rejected</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数解析-5"><a href="#函数解析-5" class="headerlink" title="函数解析:"></a>函数解析:</h4><p><strong>该方法返回的Promise对象由数组中的成员决定,如果数组成员全为resolve,则返回的Promise对象为resolve,返回结果为每一个成员的返回值组成的数组,若有一个失败,则返回的Promise对象为reject,返回的结果为该reject类型Promise对象的返回值</strong></p><h4 id="结果如下-3"><a href="#结果如下-3" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/API/4.png" alt="image"></p><h2 id="7-Promise-race-方法-promises-x3D-gt"><a href="#7-Promise-race-方法-promises-x3D-gt" class="headerlink" title="7.Promise.race 方法: (promises) &#x3D;&gt; {}"></a>7.Promise.race 方法: (promises) &#x3D;&gt; {}</h2><ul><li><strong>(1)value: 成功的数据或 promise 对象</strong><br> <strong>说明:</strong> 返回一个<strong>新的 promise</strong>, <strong>第一个完成</strong>的 promise 的结果状态就是最终的结果状态(<strong>相当于数组成员之间进行赛跑,设第一个转变状态,就返回谁</strong>)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里设置一个定时器,故意调慢p1</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>)</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);<span class="comment">//返回结果:fulfilled Success</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数解析-6"><a href="#函数解析-6" class="headerlink" title="函数解析:"></a>函数解析:</h4><p>race的本身意思就是赛跑的意思,race()方法本身接受一个参数,这个参数一般也是由一个Promise组成的数组,返回结果也是一个Promise1对象,与all有点相像,返回结果的状态由数组成员中第一个改变状态的Promise成员决定,返回结果的状态与之保持一致</p><h4 id="结果如下-4"><a href="#结果如下-4" class="headerlink" title="结果如下:"></a><strong>结果如下:</strong></h4><p><img src="/../upload/promise/API/5.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> Promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise的介绍</title>
      <link href="/2022/07/23/Promise%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/07/23/Promise%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Promise-是什么"><a href="#1-Promise-是什么" class="headerlink" title="1.Promise 是什么?"></a>1.<strong>Promise</strong> 是什么?</h1><ul><li><strong>1.抽象表达:</strong><ul><li>1)Promise 是一门新的技术(ES6 规范)</li><li>2)Promise 是 JS 中进行异步编程的新解决方案备注：旧方案是单纯使用回调函数（解决回调地狱）</li></ul></li><li><strong>2.具体表达:</strong><ul><li>1)从语法上来说: Promise 是一个构造函数</li><li>2)从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功&#x2F; 失败的结果值</li></ul></li></ul><h1 id="2-promise-的状态改变"><a href="#2-promise-的状态改变" class="headerlink" title="2.promise 的状态改变"></a>2.<strong>promise</strong> 的状态改变</h1><h2 id="一般有三种"><a href="#一般有三种" class="headerlink" title="一般有三种"></a>一般有三种</h2><ul><li><strong>pending</strong>: 它的意思是 “待定的，将发生的”，相当于是一个初始状态。创建Promise对象时，且没有调用resolve或者是reject方法，相当于是初始状态。这个初始状态会随着你调用resolve，或者是reject函数而切换到另一种状态。<br>   <img src="/../upload/promise/introduce/1.png" alt="image"></li><li><strong>reslove</strong>: 也叫<strong>fulfiller</strong>表示解决了，就是说这个承诺实现了。 要实现从pending到resolved的转变，需要在 创建Promise对象时，在函数体中调用了resolve方法(即第一个参数)。<br>   <img src="/../upload/promise/introduce/2.png" alt="image"></li><li><strong>rejected</strong>: 拒绝，失败。表示这个承诺没有做到，失败了。要实现从pending到rejected的转换，只需要在创建Promise对象时，调用reject函数。<br>   <img src="/../upload/promise/introduce/3.png" alt="image"></li></ul><h3 id="状态之间是可以相互转换的-但是这个过程是不可逆的"><a href="#状态之间是可以相互转换的-但是这个过程是不可逆的" class="headerlink" title="状态之间是可以相互转换的,但是这个过程是不可逆的"></a>状态之间是可以相互转换的,但是这个过程是不可逆的</h3><ul><li>1.pending 变为 resolved</li><li>2.pending 变为 rejected</li></ul><h3 id="说明-只有这-2-种-且一个-promise-对象只能改变一次无论变为成功还是失败-都会有一个结果数据-在then方法里面接收-成功的结果数据一般称为-value-失败的结果数据一般称为-reason"><a href="#说明-只有这-2-种-且一个-promise-对象只能改变一次无论变为成功还是失败-都会有一个结果数据-在then方法里面接收-成功的结果数据一般称为-value-失败的结果数据一般称为-reason" class="headerlink" title="说明: 只有这 2 种, 且一个 promise 对象只能改变一次无论变为成功还是失败, 都会有一个结果数据,在then方法里面接收,成功的结果数据一般称为 value, 失败的结果数据一般称为 reason"></a>说明: 只有这 2 种, 且一个 promise 对象只能改变一次无论变为成功还是失败, 都会有一个结果数据,在then方法里面接收,成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</h3><h1 id="3-promise-的基本流程"><a href="#3-promise-的基本流程" class="headerlink" title="3.promise 的基本流程"></a>3.promise 的基本流程</h1><p><img src="/../upload/promise/introduce/4.png" alt="image"></p><h1 id="4-promise-的基本使用"><a href="#4-promise-的基本使用" class="headerlink" title="4.promise 的基本使用"></a>4.promise 的基本使用</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1) 创建 promise 对象(pending 状态), 指定执行器函数</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2) 在执行器函数中启动异步任务</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">            <span class="comment">// 3) 根据结果做不同处理</span></span><br><span class="line">            <span class="comment">// 3.1) 如果成功了, 调用 resolve(), 指定成功的 value, 变为 resolved 状态</span></span><br><span class="line">            <span class="keyword">if</span> (time%<span class="number">2</span>===<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="string">&#x27;成功的值 &#x27;</span>+ time)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3.2) 如果失败了, 调用 reject(), 指定失败的 reason, 变为rejected 状态</span></span><br><span class="line">                    <span class="title function_">reject</span>(<span class="string">&#x27;失败的值&#x27;</span> + time)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4) 能 promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason </span></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// 成功的回调函数 onResolved, 得到成功的 vlaue </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的 value: &#x27;</span>, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="comment">// 失败的回调函数 onRejected, 得到失败的 reason </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的 reason: &#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> Promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Es6中的类与对象</title>
      <link href="/2022/07/20/Es6%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/07/20/Es6%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Es6中的类和对象"><a href="#Es6中的类和对象" class="headerlink" title="Es6中的类和对象"></a>Es6中的类和对象</h1><ul><li><p>相较于<strong>面向过程</strong>,<strong>面向对象</strong>更加贴近与我们的实际生活，可以使用<strong>面向对象</strong>来描述现实世界，但事物都分为具体事物和抽象事物。</p><ul><li>如一个手机就是一个抽象的事物(泛指的)</li><li>但是一台苹果X就是一个具体的事物(特指的)</li></ul></li><li><h3 id="面向对象的思维特点"><a href="#面向对象的思维特点" class="headerlink" title="面向对象的思维特点:"></a>面向对象的思维特点:</h3><ul><li><strong>1.抽取(抽象)对象的共用属性和行为方法组织(封装)成一个 类(模板)</strong><ul><li><strong>就像是每一台手机都能打电话,又有手机屏幕,都有电池,都有一个价格等…这就是手机的共同属性</strong></li></ul></li><li><strong>对 类 进行实例化,获取类的对象,如我们可以封装一个手机的 类 ,里面有名字,品牌,价格等属性,当我们调用这个 手机类 的时候,给他们赋予不一样的属性值就能产出 不同的手机,如我们给这个手机类的名字属性赋予:小米10, 品牌属性赋予:小米,那么再实例化这个类就能产出一台小米10的手机了</strong></li></ul><h4 id="所以面向对象编程考虑的就是有哪些对象-按照这些对象的思维特点-抽取它们的共同属性或方法-对象不断的创建出带有共同属性或者方法的对象-使用它们-指挥他们做事情"><a href="#所以面向对象编程考虑的就是有哪些对象-按照这些对象的思维特点-抽取它们的共同属性或方法-对象不断的创建出带有共同属性或者方法的对象-使用它们-指挥他们做事情" class="headerlink" title="所以面向对象编程考虑的就是有哪些对象,按照这些对象的思维特点,抽取它们的共同属性或方法,对象不断的创建出带有共同属性或者方法的对象,使用它们,指挥他们做事情"></a>所以面向对象编程考虑的就是有哪些对象,按照这些对象的思维特点,抽取它们的共同属性或方法,对象不断的创建出带有共同属性或者方法的对象,使用它们,指挥他们做事情</h4></li></ul><h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象?"></a>什么是对象?</h2><ul><li>在现实生活中,万物皆对象,对象是一个具体的事物,比如一辆车,一本书,一个人等…</li><li>在 JavaScript 中，对象是一组无序的<strong>相关属性和方法的集合</strong>，所有的事物都是对象，例如字符串、数值、数组、函数等。</li></ul><h3 id="对象是由属性和方法组成的："><a href="#对象是由属性和方法组成的：" class="headerlink" title="对象是由属性和方法组成的："></a>对象是由属性和方法组成的：</h3><ul><li><strong>属性：事物的特征，在对象中用属性来表示（常用名词）</strong></li><li><strong>方法：事物的行为，在对象中用方法来表示（常用动词）</strong></li></ul><h2 id="什么是-类-class"><a href="#什么是-类-class" class="headerlink" title="什么是 类 class ?"></a>什么是 类 class ?</h2><ul><li><strong>在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。</strong></li><li><strong>类抽象了对象的公共部分，它泛指某一大类（class）</strong></li><li><strong>对象特指某一个，通过类实例化一个具体的对象</strong><br>  <img src="/../upload/Es6/class/1.png" alt="image"></li><li><strong>上图中的设计图纸就是一个类,那辆车就是通过这个类实例化的对象</strong></li></ul><h1 id="重头戏-创建和使用-类"><a href="#重头戏-创建和使用-类" class="headerlink" title="重头戏:创建和使用 类"></a>重头戏:创建和使用 类</h1><ul><li><strong>注意： 类必须使用 new 实例化对象，方法之间不能加逗号分隔，同时方法不需要添加 function 关键字。</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建类 class</span><br><span class="line">        class Star&#123;</span><br><span class="line">            constructor(name , age)&#123;</span><br><span class="line">                this.name = name;</span><br><span class="line">                this.age = age;</span><br><span class="line">            &#125;</span><br><span class="line">            // 我们类里面所有的函数不需要写function ,页不需要用&quot;,&quot;分割</span><br><span class="line">            sing(song)&#123;</span><br><span class="line">                console.log(this.name + &#x27;唱的是&#x27; + song);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 使用类 new(实例化对象)</span><br><span class="line">        var ldh = new Star(&#x27;刘德华&#x27;,&#x27;20&#x27;);</span><br><span class="line">        // 执行过程如下：</span><br><span class="line">        // 1.你用 new 实例化对象，类就自动的调用 constructor 然后&#x27;刘德华&#x27;就会传递给constructor的形参 name ,name又赋值给this.name,而这个this是指向你创建的实例的,做因实例化对象内部就生成了一个 name : &#x27;刘德华&#x27; 属性</span><br><span class="line">        var zxy = new Star(&#x27;张学友&#x27;,&#x27;20&#x27;);</span><br><span class="line">        console.log(ldh);</span><br><span class="line">        console.log(zxy);</span><br><span class="line">        ldh.sing(&#x27;开心马骝&#x27;);</span><br><span class="line">        zxy.sing(&#x27;饿狼传说&#x27;)</span><br><span class="line"></span><br><span class="line">        //(1) 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</span><br><span class="line">        //(2) 类里面有个constructor 函数,可以接受传递过来的参数,同时自动返回实例对象,所以不需要调用return</span><br><span class="line">        //(3) constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数</span><br><span class="line">        //(4) 生成实例 new 不能省略</span><br><span class="line">        //(5) 最后注意语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function</span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>  <img src="/../upload/Es6/class/2.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Es6 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown的常用语法</title>
      <link href="/2022/07/20/MarkDown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/07/20/MarkDown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-标题的几种写法"><a href="#1-标题的几种写法" class="headerlink" title="1.标题的几种写法"></a>1.标题的几种写法</h1><h2 id="1-第一种-标题前面-“-”"><a href="#1-第一种-标题前面-“-”" class="headerlink" title="1)第一种(标题前面 + “#”)"></a>1)第一种(标题前面 + “#”)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#一级标题</span><br><span class="line">##二级标题</span><br><span class="line">###三级标题</span><br><span class="line">####四级标题</span><br><span class="line">#####五级标题</span><br><span class="line">######六级标题</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/1.png" alt="image"></p><ul><li><strong>前面带#号，后面带文字，分别表示h1-h6,上图可以看出，只到h6，而且h1下面会有一条横线，注意，#号后面有空格</strong></li></ul><h2 id="2-第二种-标题下面-“-x3D-x3D-x3D-”或者”—“"><a href="#2-第二种-标题下面-“-x3D-x3D-x3D-”或者”—“" class="headerlink" title="2)第二种(标题下面 + “&#x3D;&#x3D;&#x3D;”或者”—“)"></a>2)第二种(标题下面 + “&#x3D;&#x3D;&#x3D;”或者”—“)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">================</span><br><span class="line">二级标题</span><br><span class="line">---------------</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/2.png" alt="image"></p><ul><li><strong>这种方式好像只能表示一级和二级标题，而且&#x3D;和-的数量没有限制，只要大于一个就行</strong></li></ul><h2 id="3-第三种-标题前后都-“-”"><a href="#3-第三种-标题前后都-“-”" class="headerlink" title="3)第三种(标题前后都 + “#”)"></a>3)第三种(标题前后都 + “#”)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题 #</span><br><span class="line">## 二级标题 ##</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/3.png" alt="image"></p><ul><li><strong>这里的标题支持h1-h6，为了减少篇幅，我就偷个懒，只写前面二个，这个比较好理解，相当于标签闭合，注意，标题与#号要有空格</strong></li><li><strong>那既然3种都可以使用，可不可以混合使用呢？我试了一下，是可以的，但是为了让页面标签的统一性，不建议混合使用，推荐使用第一种，比较简洁，全面</strong></li></ul><h1 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h1><ul><li><strong>我们都知道，列表分为有序列表和无序列表，下面直接展示2种列表的写法：</strong></li></ul><h2 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 列表1</span><br><span class="line">+ 列表2</span><br><span class="line">- 列表3</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/4.png" alt="image"></p><ul><li><strong>可以看到，无序列表可以用* ， + ， — 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧</strong></li></ul><h2 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 有序列表</span><br><span class="line">1. 列表1</span><br><span class="line">2. 列表2</span><br><span class="line">3. 列表3</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/5.png" alt="image"></p><ul><li><strong>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的!</strong></li></ul><h3 id="比如"><a href="#比如" class="headerlink" title="比如:"></a>比如:</h3><p>  <img src="/../upload/markdown/6.png" alt="image"> <img src="/../upload/markdown/7.png" alt="image"></p><ul><li><strong>序号是乱的 3 9 1， 但是还是显示 3 4 5 ，这点必须注意了</strong></li></ul><h1 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3.区块引用"></a>3.区块引用</h1><ul><li><strong>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句</strong>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 不以结婚为目的的谈恋爱都是耍流氓</span><br><span class="line">    &gt;这是毛主席说的</span><br><span class="line">- 前方高能</span><br><span class="line">    &gt; 注意:这里是为了提醒前面有很刺激的事情发生,请做好准备</span><br></pre></td></tr></table></figure>  <img src="/../upload/markdown/8.png" alt="image"></li><li><strong>无序列表下方的便是引用，可以有多种用途，看你的需求了，用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格.</strong></li><li><strong>引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等</strong></li></ul><h3 id="另外-引用里面还可以继续套引用"><a href="#另外-引用里面还可以继续套引用" class="headerlink" title="另外 引用里面还可以继续套引用"></a>另外 引用里面还可以继续套引用</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;一级以用</span><br><span class="line">&gt;&gt;二级引用</span><br><span class="line">&gt;&gt;&gt;三级以用</span><br><span class="line">&gt;&gt;&gt;&gt;四级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;五级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;六级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;七级引用</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/9.png" alt="image"></p><h1 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h1><ul><li><em><em>分割线可以由</em> - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</em>*  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">********</span><br><span class="line">--------</span><br><span class="line">- - - - </span><br><span class="line">* * *</span><br><span class="line">----------</span><br><span class="line">- - - - </span><br></pre></td></tr></table></figure>  <img src="/../upload/markdown/10.png" alt="image"></li><li><strong>为了代码的排版好看，可以自己定规则，前面有用到星号，建议用减号</strong></li></ul><h1 id="5-链接"><a href="#5-链接" class="headerlink" title="5.链接"></a>5.链接</h1><ul><li><strong>支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。</strong></li></ul><h2 id="1-行内式"><a href="#1-行内式" class="headerlink" title="1).行内式"></a>1).行内式</h2>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 行内式</span><br><span class="line">[妙语连珠](http://www.abcd.com) 是什么意思</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/11.png" alt="image"></p><ul><li><strong>上图可知，行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中</strong></li></ul><h2 id="2-参数式"><a href="#2-参数式" class="headerlink" title="2).参数式"></a>2).参数式</h2>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 参数</span><br><span class="line">[name](http://www.abcd.com) &quot;名称&quot;</span><br><span class="line">[home](http://www.abcd.com) &quot;首页&quot;</span><br><span class="line">[也支持中文](http://www.abcd.com) &quot;..&quot;</span><br><span class="line"></span><br><span class="line">这里是[name],这里是[home],这里页是[也支持中文]</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/12.png" alt="image"></p><ul><li><strong>这就好理解了，就是把链接当成参数，适合多出使用相同链接的场景，注意参数的对应关系</strong></li></ul><h1 id="6-图片"><a href="#6-图片" class="headerlink" title="6.图片"></a>6.图片</h1><ul><li><strong>图片也有2种方式：行内式和参数式</strong>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![image](../upload/markdown/12.png)</span><br><span class="line"> [博客园]:(../upload/markdown/12.png)</span><br><span class="line"> 参数式图片,这里是![博客园]</span><br></pre></td></tr></table></figure></li><li><strong>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的</strong></li></ul><h1 id="7-代码框-这个没啥好说的"><a href="#7-代码框-这个没啥好说的" class="headerlink" title="7.代码框(这个没啥好说的)"></a>7.代码框(这个没啥好说的)</h1>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般是用:</span><br><span class="line"> ```(键盘左上角,切记一定是3个)</span><br><span class="line">代码编写区域</span><br><span class="line"> ```(键盘左上角,切记一定是3个)</span><br></pre></td></tr></table></figure><h1 id="8-表格-比较麻烦"><a href="#8-表格-比较麻烦" class="headerlink" title="8.表格(比较麻烦)"></a>8.表格(比较麻烦)</h1>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 表格</span><br><span class="line">| name | age | sex |</span><br><span class="line">|:----:|:---:|:---:|</span><br><span class="line">| tony | 20  | 男  |</span><br><span class="line">| lucy | 18  | 女  |</span><br><span class="line"></span><br><span class="line">表头!  |  表头2</span><br><span class="line">------- | -----------</span><br><span class="line">Content Cell | Content Cell</span><br><span class="line">Content Cell | Content Cell</span><br><span class="line"></span><br><span class="line">学号 | 姓名 | 分数</span><br><span class="line">  -  |  -   |  -</span><br><span class="line">小明 | 男   | 75</span><br><span class="line">小红 | 女   | 79</span><br><span class="line">小陆 | 男   | 92</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/13.png" alt="image"></p><ul><li><strong>从这3种不同写法看，表格的格式不一定要对的非常齐，但是为了好看，对齐肯定是最好的，第一种的分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中，还是有点意思的，不过现实出来的结果是，表格外面并没有线框包起来，不知道别人的怎么弄的</strong></li></ul><h1 id="9-强调"><a href="#9-强调" class="headerlink" title="9.强调"></a>9.强调</h1>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 强调</span><br><span class="line">*字体倾斜*</span><br><span class="line">_字体倾斜_</span><br><span class="line">**字体加粗**</span><br><span class="line">__字体加粗__</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/14.png" alt="image"></p><ul><li><strong>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</strong></li></ul><h1 id="10-转义"><a href="#10-转义" class="headerlink" title="10.转义"></a>10.转义</h1>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 转义</span><br><span class="line">* \\</span><br><span class="line">* \`</span><br><span class="line">* \~</span><br><span class="line">* \*</span><br><span class="line">* \_</span><br><span class="line">* \-</span><br><span class="line">* \+</span><br><span class="line">* \.</span><br><span class="line">* \!</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/15.png" alt="image"></p><ul><li><strong>就不一一列举了，基本上跟js转义是一样的</strong></li></ul><h1 id="11-删除线"><a href="#11-删除线" class="headerlink" title="11.删除线"></a>11.删除线</h1>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 删除线</span><br><span class="line">~~请删掉我把~~</span><br></pre></td></tr></table></figure><p>  <img src="/../upload/markdown/16.png" alt="image"></p><h2 id="以上便是编写md文档的常用语法了-感谢观看"><a href="#以上便是编写md文档的常用语法了-感谢观看" class="headerlink" title="以上便是编写md文档的常用语法了!感谢观看!!"></a>以上便是编写md文档的常用语法了!感谢观看!!</h2><blockquote><p>这篇博客引用了作者为”<strong>斧子兔</strong>“的文章<br>原文链接为:<a href="https://www.cnblogs.com/fuzitu/p/10471073.html">CSDN</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown的常用语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象和面向过程的编程思想对比</title>
      <link href="/2022/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="编程的两大思想"><a href="#编程的两大思想" class="headerlink" title="编程的两大思想"></a><strong>编程的两大思想</strong></h1><ul><li><strong>1.面向过程(Procedure-Oriented programming)<strong>：是一种</strong>以过程为中心</strong>的编程思想。这些都是以什么正在发生为主要目标进行编程，直白点说就是分析一个要求实现所需要的步骤，然后一步一步的将这些步骤实现，举个例子：将大象装进冰箱需要三步：打开冰箱——装进大象——关上冰箱。<br>  <img src="/../upload/pop-oop/1.png" alt="image"></li><li><strong>2.面向对象(Object-Oriented programming)<strong>：作为一种新的编程思想，其本质是将要求</strong>分解成一个个对象</strong>，<strong>给他们赋予一些独特的属性或者方法</strong>，然后对象之间相互合作实现要求。还是原来的那个例子，大象装进冰箱，用面向对象的编程思想的话就是这样解决的：<ul><li>封装两个<strong>对象</strong>：<ul><li><strong>大象对象</strong>：属性或方法：进入冰箱</li><li><strong>冰箱对象</strong>：属性或方法：打开冰箱，关闭冰箱</li></ul></li><li>最后调用这些对象的属性或者方法来解决问题<br>  <img src="/../upload/pop-oop/2.png" alt="image"></li></ul></li></ul><h2 id="面向对象的特性："><a href="#面向对象的特性：" class="headerlink" title="面向对象的特性："></a>面向对象的特性：</h2><h3 id="1、封装性-2、继承性-3、多态性"><a href="#1、封装性-2、继承性-3、多态性" class="headerlink" title="1、封装性  2、继承性  3、多态性"></a>1、封装性  2、继承性  3、多态性</h3><p>  <img src="/../upload/pop-oop/3.png" alt="image"></p><h2 id="面向过程编程思想的优点：-适用于简单的程序需求"><a href="#面向过程编程思想的优点：-适用于简单的程序需求" class="headerlink" title="面向过程编程思想的优点：(适用于简单的程序需求)"></a>面向过程编程思想的优点：(适用于简单的程序需求)</h2><ul><li><strong>性能比面面向对象高，适合与硬件紧密联系起来，例如单片机编程就经常使用面向过程编程。</strong></li></ul><h2 id="面向对象编程思想的优点：-适用于复杂，大型的项目需求"><a href="#面向对象编程思想的优点：-适用于复杂，大型的项目需求" class="headerlink" title="面向对象编程思想的优点：(适用于复杂，大型的项目需求)"></a>面向对象编程思想的优点：(适用于复杂，大型的项目需求)</h2><ul><li><strong>易于维护，易于复用，易于扩展，由于面向对象有封装性，继承性和多态性的特点，可以设计出低耦合的系统，是系统更加灵活，易于维护。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象和面向过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise解决回调地狱</title>
      <link href="/2022/07/19/Promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/"/>
      <url>/2022/07/19/Promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise解决回调地狱问题"><a href="#Promise解决回调地狱问题" class="headerlink" title="Promise解决回调地狱问题"></a><strong>Promise</strong>解决回调地狱问题</h1><h2 id="什么是Promise？"><a href="#什么是Promise？" class="headerlink" title="什么是Promise？"></a>什么是<strong>Promise</strong>？</h2><ul><li><strong>Promise</strong> 是<strong>ES6</strong> 引入的异步编程的新解决方案。语法上 <strong>Promise</strong> 是一个构造函数， 用来<strong>封装异步操作</strong>并可以获取其成功或失败的结果。</li></ul><h2 id="什么是回调地狱？"><a href="#什么是回调地狱？" class="headerlink" title="什么是回调地狱？"></a>什么是<strong>回调地狱</strong>？</h2><ul><li>所谓回调地狱就是在回调函数里面不断的嵌套回调函数，这样就会导致代码不断缩进，可读性就会变得非常的差。</li><li>比如我要执行1秒打印一个人的姓名：<br>  <img src="/../upload/promise/1.png" alt="image"></li></ul><h2 id="这里我们可以使用Promise来解决回调地狱的问题"><a href="#这里我们可以使用Promise来解决回调地狱的问题" class="headerlink" title="这里我们可以使用Promise来解决回调地狱的问题"></a>这里我们可以使用<strong>Promise</strong>来解决回调地狱的问题</h2><ul><li>因为<strong>Promise</strong>存在一种链式调用</li><li>我们可以调用<strong>Promise</strong>中的<strong>then</strong>方法构成<strong>链式调用</strong>，代码如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const p = new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        var s = &#x27;老一&#x27;;</span><br><span class="line">        reslove(s);</span><br><span class="line">    &#125; , 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var s = &#x27;老二&#x27;;</span><br><span class="line">            reslove(s);</span><br><span class="line">        &#125; , 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var s = &#x27;老三&#x27;;</span><br><span class="line">            reslove(s);</span><br><span class="line">        &#125; , 1000)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var s = &#x27;老四&#x27;;</span><br><span class="line">            reslove(s);</span><br><span class="line">        &#125; , 1000)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var s = &#x27;老五&#x27;;</span><br><span class="line">            reslove(s);</span><br><span class="line">        &#125; , 1000)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return new Promise((reslove , reject) =&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var s = &#x27;老六&#x27;;</span><br><span class="line">            reslove(s);</span><br><span class="line">        &#125; , 1000)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下:"></a>运行结果如下:</h2><p><img src="/../upload/promise/2.png" alt="image"></p><h3 id="输出结果是一致的，但是解决了回调地狱的问题"><a href="#输出结果是一致的，但是解决了回调地狱的问题" class="headerlink" title="输出结果是一致的，但是解决了回调地狱的问题"></a><strong>输出结果是一致的，但是解决了回调地狱的问题</strong></h3><h2 id="原理刨析-链式调用的原理"><a href="#原理刨析-链式调用的原理" class="headerlink" title="原理刨析:(链式调用的原理)"></a><strong>原理刨析:(链式调用的原理)</strong></h2><ul><li><strong>调用 then 方法 then方法的返回结果是 Promise 对象, 对象状态由回调函数的执行结果决定</strong><ul><li>1).非 promise 类型的属性, 状态为成功或者失败, 返回值就是return后面跟着的值</li><li>2).是 promise 类型的属性, 状态为成功或者失败, 返回值就是return后面跟着的新的promise对象的reslove()或者reject()</li></ul></li><li><strong>在我看来，之所以Promise能够解决回调地狱的问题主要归功于 then 方法，then方法里面有一个return属性，而这个return属性当返回的是一个Promise对象时，那么如果后面还有嵌套的.then的话，返回的Promise对象就直接对接后面的.then方法，相当于上层Promise对象返回的新Promise对象就继续对接后面的.then方法，以此类推来解决回调地狱。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端知识分享 </category>
          
          <category> Promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git中常见的报错</title>
      <link href="/2022/07/18/git%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%A5%E9%94%99/"/>
      <url>/2022/07/18/git%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h2 id="Git常见错误1"><a href="#Git常见错误1" class="headerlink" title="Git常见错误1:"></a>Git常见错误1:</h2><ul><li><h3 id="在git-bash中输入指令-git-status查看本地库状态时报错"><a href="#在git-bash中输入指令-git-status查看本地库状态时报错" class="headerlink" title="在git bash中输入指令:git status查看本地库状态时报错:"></a>在git bash中输入指令:git status查看本地库状态时报错:</h3> <img src="/../upload/git/git-wrong/1.png" alt="image"></li><li><h3 id="原因"><a href="#原因" class="headerlink" title="原因 :"></a>原因 :</h3></li><li>这个错误说明了没有 .git这样的一个目录，所以只需要 git init一下，就可以解决了，然后再重新建立远程连接即可.</li></ul><h2 id="Git常见错误2"><a href="#Git常见错误2" class="headerlink" title="Git常见错误2:"></a>Git常见错误2:</h2><ul><li><h3 id="在git-bash中输入指令-git-status查看本地库状态时报错-1"><a href="#在git-bash中输入指令-git-status查看本地库状态时报错-1" class="headerlink" title="在git bash中输入指令:git status查看本地库状态时报错:"></a>在git bash中输入指令:git status查看本地库状态时报错:</h3> <img src="/../upload/git/git-wrong/2.png" alt="image"></li><li><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因 :"></a>原因 :</h3></li><li>原因是在 xxx&#x2F;文件夹下有隐藏文件，删除掉即可(因为这是我博客的文件夹,里面存在.git的吟唱文件,执行git init时添加的,用于初始化本地库的)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
            <tag> git中常用的报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git中常用的linux指令</title>
      <link href="/2022/07/18/git%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84linux%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/07/18/git%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84linux%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="git中常用的linux指令有如下几个"><a href="#git中常用的linux指令有如下几个" class="headerlink" title="git中常用的linux指令有如下几个"></a><strong>git中常用的linux指令有如下几个</strong></h1><ul><li><h3 id="1、cd-改变目录-进入指定文件夹-。"><a href="#1、cd-改变目录-进入指定文件夹-。" class="headerlink" title="1、cd : 改变目录(进入指定文件夹)。"></a>1、cd : 改变目录(进入指定文件夹)。</h3> <img src="/../upload/git/git-linux-command/1.png" alt="image"></li><li><h3 id="2、cd-回退到上一个目录，直接cd进入默认目录"><a href="#2、cd-回退到上一个目录，直接cd进入默认目录" class="headerlink" title="2、cd .. : 回退到上一个目录，直接cd进入默认目录"></a>2、cd .. : 回退到上一个目录，直接cd进入默认目录</h3></li><li><h3 id="3、cd-：返回最近访问目录"><a href="#3、cd-：返回最近访问目录" class="headerlink" title="3、cd -  ：返回最近访问目录"></a>3、cd -  ：返回最近访问目录</h3> <img src="/../upload/git/git-linux-command/2.png" alt="image"></li><li><h3 id="4、pwd-显示当前所在的目录路径"><a href="#4、pwd-显示当前所在的目录路径" class="headerlink" title="4、pwd : 显示当前所在的目录路径"></a>4、pwd : 显示当前所在的目录路径</h3> <img src="/../upload/git/git-linux-command/3.png" alt="image"></li><li><h3 id="5、ls-ll-都是列出当前目录中的所有文件，相较于ls，ll列出的内容更为详细（包括权限、所属用户和组、大小、时间、名称等）"><a href="#5、ls-ll-都是列出当前目录中的所有文件，相较于ls，ll列出的内容更为详细（包括权限、所属用户和组、大小、时间、名称等）" class="headerlink" title="5、ls(ll): 都是列出当前目录中的所有文件，相较于ls，ll列出的内容更为详细（包括权限、所属用户和组、大小、时间、名称等）"></a>5、ls(ll): 都是列出当前目录中的所有文件，相较于ls，ll列出的内容更为详细（包括权限、所属用户和组、大小、时间、名称等）</h3> <img src="/../upload/git/git-linux-command/4.png" alt="image"><br> <img src="/../upload/git/git-linux-command/5.png" alt="image"></li><li><h3 id="6、ls-a-显示该文件夹中的隐藏文件"><a href="#6、ls-a-显示该文件夹中的隐藏文件" class="headerlink" title="6、ls -a : 显示该文件夹中的隐藏文件"></a>6、ls -a : 显示该文件夹中的隐藏文件</h3></li><li><h3 id="7、ls-l-列出文件的详细信息。"><a href="#7、ls-l-列出文件的详细信息。" class="headerlink" title="7、ls -l : 列出文件的详细信息。"></a>7、ls -l : 列出文件的详细信息。</h3></li><li><h3 id="8、touch-新建一个文件-如-touch-index-js-就会在当前目录下新建一个index-js文件。"><a href="#8、touch-新建一个文件-如-touch-index-js-就会在当前目录下新建一个index-js文件。" class="headerlink" title="8、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。"></a>8、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</h3> <img src="/../upload/git/git-linux-command/6.png" alt="image"></li><li><h3 id="9、rm-删除一个文件-rm-index-js-就会把index-js文件删除。"><a href="#9、rm-删除一个文件-rm-index-js-就会把index-js文件删除。" class="headerlink" title="9、rm: 删除一个文件, rm index.js 就会把index.js文件删除。"></a>9、rm: 删除一个文件, rm index.js 就会把index.js文件删除。</h3> <img src="/../upload/git/git-linux-command/7.png" alt="image"></li><li><h3 id="10、mkdir-新建一个目录-就是新建一个文件夹"><a href="#10、mkdir-新建一个目录-就是新建一个文件夹" class="headerlink" title="10、mkdir: 新建一个目录,就是新建一个文件夹"></a>10、mkdir: 新建一个目录,就是新建一个文件夹</h3></li><li><h3 id="11、rm-r-删除一个文件夹-rm-r-src-删除src目录rm-rf-x2F-切勿在Linux中尝试！删除电-脑中全部文件！"><a href="#11、rm-r-删除一个文件夹-rm-r-src-删除src目录rm-rf-x2F-切勿在Linux中尝试！删除电-脑中全部文件！" class="headerlink" title="11、rm -r : 删除一个文件夹, rm -r src 删除src目录rm -rf &#x2F; 切勿在Linux中尝试！删除电## 脑中全部文件！"></a>11、rm -r : 删除一个文件夹, rm -r src 删除src目录rm -rf &#x2F; 切勿在Linux中尝试！删除电## 脑中全部文件！</h3></li><li><h3 id="12、mv-移动文件-mv-index-html-src-。index-html-是我们要移动的文件-src-是目标文件夹-当然-这样写-必须保证文件和目标文件夹在同一目录下。"><a href="#12、mv-移动文件-mv-index-html-src-。index-html-是我们要移动的文件-src-是目标文件夹-当然-这样写-必须保证文件和目标文件夹在同一目录下。" class="headerlink" title="12、mv : 移动文件, mv index.html src 。index.html 是我们要移动的文件, src 是目标文件夹## ,当然, 这样写,必须保证文件和目标文件夹在同一目录下。"></a>12、mv : 移动文件, mv index.html src 。index.html 是我们要移动的文件, src 是目标文件夹## ,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</h3></li><li><h3 id="13、reset-重新初始化终端-x2F-清屏。"><a href="#13、reset-重新初始化终端-x2F-清屏。" class="headerlink" title="13、reset : 重新初始化终端&#x2F;清屏。"></a>13、reset : 重新初始化终端&#x2F;清屏。</h3></li><li><h3 id="14、clear-清屏。"><a href="#14、clear-清屏。" class="headerlink" title="14、clear : 清屏。"></a>14、clear : 清屏。</h3></li><li><h3 id="15、history-查看命令历史。"><a href="#15、history-查看命令历史。" class="headerlink" title="15、history : 查看命令历史。"></a>15、history : 查看命令历史。</h3></li><li><h3 id="16、help-帮助。"><a href="#16、help-帮助。" class="headerlink" title="16、help : 帮助。"></a>16、help : 帮助。</h3></li><li><h3 id="17、exit-退出。"><a href="#17、exit-退出。" class="headerlink" title="17、exit : 退出。"></a>17、exit : 退出。</h3></li><li><h3 id="18、-表示注释"><a href="#18、-表示注释" class="headerlink" title="18、# : 表示注释"></a>18、# : 表示注释</h3></li><li><h3 id="19、cat-在控制台中显示文件的全部信息-即打开该文件"><a href="#19、cat-在控制台中显示文件的全部信息-即打开该文件" class="headerlink" title="19、cat : 在控制台中显示文件的全部信息,即打开该文件"></a>19、cat : 在控制台中显示文件的全部信息,即打开该文件</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
            <tag> git中常用的linux指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记(4)-git远程库操作</title>
      <link href="/2022/07/18/git%E8%BF%9C%E7%A8%8B%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/07/18/git%E8%BF%9C%E7%A8%8B%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="git远程库操作指令"><a href="#git远程库操作指令" class="headerlink" title="git远程库操作指令"></a><strong>git</strong>远程库操作指令</h1><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v                      查看当前所有远程地址别名</span><br><span class="line">git remote add 别名 远程地址        起别名</span><br><span class="line">git push 别名 分支                  推送本地分支上的内容到远程仓库</span><br><span class="line">git clone 远程地址                  将远程仓库的内容克隆到本地</span><br><span class="line">git pull 远程库地址别名 远程分支名   将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</span><br></pre></td></tr></table></figure></code></pre><ul><li><h3 id="1-创建远程仓库别名-实操"><a href="#1-创建远程仓库别名-实操" class="headerlink" title="1.创建远程仓库别名(实操)"></a>1.创建远程仓库别名(实操)</h3><ul><li><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v 查看当前所有远程地址别名</span><br><span class="line">git remote add 别名 远程地址</span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例"><a href="#实操案例" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command3/1.png" alt="image"></li><li><strong>这个地址在创建完远程仓库后生成的连接，如图所示红框中</strong><br><img src="/../upload/git/git-command3/2.png" alt="image"></li></ul></li><li><h3 id="2-推送本地分支到远程仓库-实操"><a href="#2-推送本地分支到远程仓库-实操" class="headerlink" title="2.推送本地分支到远程仓库(实操)"></a>2.推送本地分支到远程仓库(实操)</h3><ul><li><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push 别名 分支</span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例-1"><a href="#实操案例-1" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command3/3.png" alt="image"></li><li><strong>此时发现已将我们master 分支上的内容推送到GitHub 创建的远程仓库。</strong><br><img src="/../upload/git/git-command3/4.png" alt="image"></li></ul></li><li><h3 id="3-克隆远程仓库到本地-实操"><a href="#3-克隆远程仓库到本地-实操" class="headerlink" title="3.克隆远程仓库到本地(实操)"></a>3.克隆远程仓库到本地(实操)</h3><ul><li><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 远程地址</span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例-2"><a href="#实操案例-2" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command3/5.png" alt="image"></li><li><strong>克隆结果：1、拉取代码 2、初始化本地仓库 3、自动帮你创建别名(origin)</strong><br><img src="/../upload/git/git-command3/6.png" alt="image"><br><img src="/../upload/git/git-command3/7.png" alt="image"></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>你开始对本地代码动手编写之前，一个好习惯是先把本地代码更新一下，通过pull操作使本地库在开始动手之前的那一刻与远程库版本一致，再进行本地代码的撰写，这样写完以后才push到远程仓库。</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
            <tag> 远程库操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记(3)-git的常用指令(2)</title>
      <link href="/2022/07/18/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A42/"/>
      <url>/2022/07/18/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A42/</url>
      
        <content type="html"><![CDATA[<h1 id="git的分支操作"><a href="#git的分支操作" class="headerlink" title="git的分支操作"></a><strong>git</strong>的分支操作</h1><ul><li><h2 id="什么是分支"><a href="#什么是分支" class="headerlink" title="什么是分支"></a><strong>什么是分支</strong></h2><ul><li>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）<br> <img src="/../upload/git/git-command2/1.png" alt="image"></li><li>Hot-fix(热修),表示紧急处理当前的分支,feature表示分支版本的新增功能,后续可以与主分支合并成为新的版本。</li></ul><h2 id="分支的好处"><a href="#分支的好处" class="headerlink" title="分支的好处"></a><strong>分支的好处</strong></h2><ul><li>同时并行推进多个功能开发，提高开发效率。</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可</li></ul></li><li><h2 id="分支常用指令"><a href="#分支常用指令" class="headerlink" title="分支常用指令"></a><strong>分支常用指令</strong></h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch 分支名           创建分支</span><br><span class="line">git branch -v               查看分支</span><br><span class="line">git checkout 分支名         切换分支</span><br><span class="line">git merge 分支名            把指定的分支合并到当前分支上</span><br></pre></td></tr></table></figure></li><li><h3 id="1-查看分支-实操"><a href="#1-查看分支-实操" class="headerlink" title="1.查看分支(实操)"></a>1.查看分支(实操)</h3><ul><li><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -v </span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例"><a href="#实操案例" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command2/2.png" alt="image"></li></ul></li><li><h3 id="2-创建分支-实操"><a href="#2-创建分支-实操" class="headerlink" title="2.创建分支(实操)"></a>2.创建分支(实操)</h3><ul><li><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch 分支名 </span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例-1"><a href="#实操案例-1" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command2/3.png" alt="image"></li></ul></li><li><h3 id="3-修改分支-实操"><a href="#3-修改分支-实操" class="headerlink" title="3.修改分支(实操)"></a>3.修改分支(实操)</h3><ul><li><h4 id="实操案例-2"><a href="#实操案例-2" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command2/4.png" alt="image"><br><img src="/../upload/git/git-command2/5.png" alt="image"></li></ul></li><li><h3 id="4-切换分支-实操"><a href="#4-切换分支-实操" class="headerlink" title="4.切换分支(实操)"></a>4.切换分支(实操)</h3><ul><li><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例-3"><a href="#实操案例-3" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command2/6.png" alt="image"><br><img src="/../upload/git/git-command2/7.png" alt="image"></li></ul></li><li><h3 id="5-合并分支-实操"><a href="#5-合并分支-实操" class="headerlink" title="5.合并分支(实操)"></a>5.合并分支(实操)</h3><ul><li><h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure></li><li><h4 id="实操案例-4"><a href="#实操案例-4" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h4><img src="/../upload/git/git-command2/8.png" alt="image"></li><li><h2 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a><strong>分支冲突</strong></h2><ul><li><h3 id="冲突产生的表现：后面状态为-MERGING-合并中"><a href="#冲突产生的表现：后面状态为-MERGING-合并中" class="headerlink" title="冲突产生的表现：后面状态为 MERGING(合并中)"></a><strong>冲突产生的表现：后面状态为 MERGING(合并中)</strong></h3>  <img src="/../upload/git/git-command2/9.png" alt="image"><br>  <img src="/../upload/git/git-command2/10.png" alt="image"></li><li><h3 id="冲突产生的原因："><a href="#冲突产生的原因：" class="headerlink" title="冲突产生的原因："></a><strong>冲突产生的原因：</strong></h3><ul><li>合并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。Git 无法替我们决定使用哪一个。必须<strong>人为决定</strong>新代码内容。</li><li><strong>查看状态（检测到有文件有两处修改）</strong><br>  <img src="/../upload/git/git-command2/11.png" alt="image"></li></ul></li><li><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a><strong>解决冲突</strong></h3><ul><li><h3 id="1）编辑有冲突的文件，删除特殊符号，决定要使用的内容"><a href="#1）编辑有冲突的文件，删除特殊符号，决定要使用的内容" class="headerlink" title="1）编辑有冲突的文件，删除特殊符号，决定要使用的内容"></a>1）编辑有冲突的文件，删除特殊符号，决定要使用的内容</h3>  <strong>特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;合并过来的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</strong><br>  <img src="/../upload/git/git-command2/12.png" alt="image"><br>  <img src="/../upload/git/git-command2/13.png" alt="image"></li><li><h3 id="2）添加到暂存区"><a href="#2）添加到暂存区" class="headerlink" title="2）添加到暂存区"></a>2）添加到暂存区</h3>  <img src="/../upload/git/git-command2/14.png" alt="image"></li><li><h3 id="3）执行提交（注意：此时使用-git-commit-命令时不能带文件名后缀名）"><a href="#3）执行提交（注意：此时使用-git-commit-命令时不能带文件名后缀名）" class="headerlink" title="3）执行提交（注意：此时使用 git commit 命令时不能带文件名后缀名）"></a>3）执行提交（注意：此时使用 git commit 命令时不能带文件名后缀名）</h3>  <img src="/../upload/git/git-command2/15.png" alt="image"></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
            <tag> git的常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记(2)-git的常用指令</title>
      <link href="/2022/07/17/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/07/17/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="git常用指令"><a href="#git常用指令" class="headerlink" title="git常用指令"></a><strong>git</strong>常用指令</h1><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name 用户名(自定义)       设置用户签名</span><br><span class="line">git config --global user.email 邮箱(可以是虚拟的)  设置用户签名</span><br><span class="line">git init                                          初始化本地库</span><br><span class="line">git status                                        查看本地库状态</span><br><span class="line">git add 文件名                                     添加到暂存区</span><br><span class="line">git rm --cached 文件名                            将指定文件从暂存区中删除,但保留工作区的文件</span><br><span class="line">git commit -m &quot;日志信息&quot; 文件名                    提交到本地库</span><br><span class="line">git reflog(也可简写为git log)                      查看历史记录</span><br><span class="line">git reset --hard 版本号                            版本穿梭</span><br></pre></td></tr></table></figure></code></pre><h2 id="1-设置用户签名-实操"><a href="#1-设置用户签名-实操" class="headerlink" title="1.设置用户签名(实操)"></a>1.设置用户签名(实操)</h2><ul><li><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name 用户名</span><br><span class="line">git config --global user.email 邮箱</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例"><a href="#实操案例" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/1.png" alt="image"></li><li><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3> 签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。<strong>注意:</strong> 这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</li></ul><h2 id="2-初始化本地库-实操"><a href="#2-初始化本地库-实操" class="headerlink" title="2.初始化本地库(实操)"></a>2.初始化本地库(实操)</h2><ul><li><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  init </span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-1"><a href="#实操案例-1" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/2.png" alt="image"></li><li><strong>结果查看</strong><br>  <img src="/../upload/git/git-command/3.png" alt="image"></li></ul><h2 id="3-查看本地库状态"><a href="#3-查看本地库状态" class="headerlink" title="3.查看本地库状态"></a>3.查看本地库状态</h2><ul><li><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status </span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-2"><a href="#实操案例-2" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/4.png" alt="image"></li><li><h3 id="新增文件-hello-txt"><a href="#新增文件-hello-txt" class="headerlink" title="新增文件(hello.txt)"></a><strong>新增文件(hello.txt)</strong></h3>  <img src="/../upload/git/git-command/5.png" alt="image"></li><li><h3 id="再次查看-检测到未追踪的文件即文件为红色表示未添加到暂存区"><a href="#再次查看-检测到未追踪的文件即文件为红色表示未添加到暂存区" class="headerlink" title="再次查看(检测到未追踪的文件即文件为红色表示未添加到暂存区)"></a><strong>再次查看(检测到未追踪的文件即文件为红色表示未添加到暂存区)</strong></h3>  <img src="/../upload/git/git-command/6.png" alt="image"></li></ul><h2 id="4-添加暂存区"><a href="#4-添加暂存区" class="headerlink" title="4.添加暂存区"></a>4.添加暂存区</h2><ul><li><h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add 文件名</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-3"><a href="#实操案例-3" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/7.png" alt="image"></li><li><h3 id="查看状态（检测到暂存区有新文件-文件变绿）"><a href="#查看状态（检测到暂存区有新文件-文件变绿）" class="headerlink" title="查看状态（检测到暂存区有新文件,文件变绿）"></a><strong>查看状态（检测到暂存区有新文件,文件变绿）</strong></h3> <img src="/../upload/git/git-command/8.png" alt="image"></li></ul><h2 id="5-提交本地库-将暂存区的文件提交到本地库"><a href="#5-提交本地库-将暂存区的文件提交到本地库" class="headerlink" title="5.提交本地库(将暂存区的文件提交到本地库)"></a>5.提交本地库(将暂存区的文件提交到本地库)</h2><ul><li><h3 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;日志信息&quot; 文件名</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-4"><a href="#实操案例-4" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/9.png" alt="image"></li><li><h3 id="查看状态（没有文件需要提交）"><a href="#查看状态（没有文件需要提交）" class="headerlink" title="查看状态（没有文件需要提交）"></a><strong>查看状态（没有文件需要提交）</strong></h3> <img src="/../upload/git/git-command/10.png" alt="image"></li></ul><h2 id="6修改文件（hello-txt）"><a href="#6修改文件（hello-txt）" class="headerlink" title="6修改文件（hello.txt）"></a>6修改文件（hello.txt）</h2><ul><li><h3 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim 文件名</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-5"><a href="#实操案例-5" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/11.png" alt="image"></li><li><h3 id="查看状态（检测到工作区有文件被修改）"><a href="#查看状态（检测到工作区有文件被修改）" class="headerlink" title="查看状态（检测到工作区有文件被修改）"></a><strong>查看状态（检测到工作区有文件被修改）</strong></h3> <img src="/../upload/git/git-command/12.png" alt="image"></li><li><h3 id="将修改的文件再次添加暂存区）"><a href="#将修改的文件再次添加暂存区）" class="headerlink" title="将修改的文件再次添加暂存区）"></a><strong>将修改的文件再次添加暂存区）</strong></h3> <img src="/../upload/git/git-command/13.png" alt="image"></li><li><h3 id="查看状态（工作区的修改添加到了暂存区）"><a href="#查看状态（工作区的修改添加到了暂存区）" class="headerlink" title="查看状态（工作区的修改添加到了暂存区）"></a><strong>查看状态（工作区的修改添加到了暂存区）</strong></h3> <img src="/../upload/git/git-command/14.png" alt="image"></li></ul><h2 id="7-查看历史版本"><a href="#7-查看历史版本" class="headerlink" title="7.查看历史版本"></a>7.查看历史版本</h2><ul><li><h3 id="基本语法-6"><a href="#基本语法-6" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog查看版本信息</span><br><span class="line">git log查看版本详细信息</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-6"><a href="#实操案例-6" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/15.png" alt="image"></li></ul><h2 id="8-版本穿梭"><a href="#8-版本穿梭" class="headerlink" title="8.版本穿梭"></a>8.版本穿梭</h2><ul><li><h3 id="基本语法-7"><a href="#基本语法-7" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure></li><li><h3 id="实操案例-7"><a href="#实操案例-7" class="headerlink" title="实操案例"></a><strong>实操案例</strong></h3> <img src="/../upload/git/git-command/16.png" alt="image"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
            <tag> git的常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的学习笔记(1)</title>
      <link href="/2022/07/17/git%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/17/git%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="git的学习笔记（1）"><a href="#git的学习笔记（1）" class="headerlink" title="git的学习笔记（1）"></a><strong>git</strong>的学习笔记（1）</h1><h2 id="1-什么是git？"><a href="#1-什么是git？" class="headerlink" title="1.什么是git？"></a>1.什么是<strong>git</strong>？</h2><ul><li><strong>Git</strong>是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种项目。</li><li><strong>Git</strong>易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。</li></ul><h2 id="2-什么是版本控制工具-集中式和分布式"><a href="#2-什么是版本控制工具-集中式和分布式" class="headerlink" title="2.什么是版本控制工具(集中式和分布式)"></a>2.什么是版本控制工具(集中式和分布式)</h2><ul><li>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</li><li>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本， 方便版本切换。</li></ul><h4 id="1-集中式版本控制工具"><a href="#1-集中式版本控制工具" class="headerlink" title="1)集中式版本控制工具"></a>1)集中式版本控制工具</h4><ul><li><strong>集中化的版本控制系统</strong>诸如 CVS、SVN 等，<strong>都有一个单一的集中管理的服务器</strong>，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</li><li>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</li><li>事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。<br> <img src="/../upload/git/1.png" alt="image"></li></ul><h4 id="2-分布式版本控制工具"><a href="#2-分布式版本控制工具" class="headerlink" title="2)分布式版本控制工具"></a>2)分布式版本控制工具</h4><ul><li>像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</li></ul><h5 id="分布式的版本控制系统出现之后-解决了集中式版本控制系统的缺陷"><a href="#分布式的版本控制系统出现之后-解决了集中式版本控制系统的缺陷" class="headerlink" title="分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:"></a><strong>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:</strong></h5><ul><li>(1).服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li><li>(2).每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）<br> <img src="/../upload/git/2.png" alt="image"></li></ul><h2 id="3-工作机制"><a href="#3-工作机制" class="headerlink" title="3.工作机制"></a>3.工作机制</h2><h4 id="Git的分区包括工作区、暂存区、本地仓库（本地版本库）、远程仓库（远程版本库）。"><a href="#Git的分区包括工作区、暂存区、本地仓库（本地版本库）、远程仓库（远程版本库）。" class="headerlink" title="Git的分区包括工作区、暂存区、本地仓库（本地版本库）、远程仓库（远程版本库）。"></a>Git的分区包括工作区、暂存区、本地仓库（本地版本库）、远程仓库（远程版本库）。</h4><ul><li>1.<strong>工作区:</strong> 所谓工作区就是写代码的地方但并非开发工具（开发平台）代码存放的磁盘的目录的位置</li><li>2.<strong>暂存区:</strong> 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。工作区写好的代码需要让git追踪到，因此你需要将工作区的代码添加（git add）到暂存区,暂存区的代码是临时存储(没有生成历史版本),即暂存区和工作区的代码均可以被删除</li><li>3.<strong>本地库:</strong> 将暂存区的代码提交(git commit)到本地库就会生成对应的历史版本,即不可能删除掉了,除非你将整个本地库删除</li><li>4.<strong>远程库:</strong> 将本地库的代码推送(push)到远程库(github),可用于远程恢复代码,当我们的电脑磁盘损坏亦或者新版本代码错误过多时可以通过远程库进行版本的回退以及代码的回滚<ul><li><strong>远程库</strong>又称<strong>代码托管中心</strong>，是基于网络服务器的远程代码仓库<ul><li><strong>GitLab</strong>(基于局域网的代码托管中心)</li><li><strong>GitHub</strong>（外网）</li><li><strong>Gitee</strong> 码云（国内网站，相当于国内的github）<br><img src="/../upload/git/4.png" alt="image"></li></ul></li></ul></li></ul><h4 id="具体实现流程"><a href="#具体实现流程" class="headerlink" title="具体实现流程"></a>具体实现流程</h4><ul><li>假如要实现上传代码功能，工作区使用add添加文件到暂存区，暂存区再通过commit提交版本给本地仓库，最后本地仓库使用push将版本推送到远程仓库；</li><li>工作区修改的文件可以通过checkout命令从本地仓库或暂存区恢复；如果要将工作区某分支的代码更新为远程仓库最新版本，可以使用pull命令；</li><li>对远程仓库使用clone可以将远程仓库主分支拷贝到本地仓库，fetch命令与pull类似，只是pull会合并本地代码，而fetch只会把最新版本抓取到本地版本库，不考虑本地仓库是否有新增。</li></ul><blockquote><p>这类git博客主要引用了作者为”<strong>尚硅谷</strong>“的文章，是博主在学习尚硅谷的<strong>git</strong>教程做的一些笔记<br>这篇博客另外引用了作者为”<strong>luffylv</strong>“和”<strong>长期闲置</strong>“的文章<br>原文链接为:<a href="https://www.bilibili.com/video/BV1vy4y1s7k6?p=1&vd_source=eeca4958b140403ede65df6022e4b306">BiliBili</a>、<a href="https://blog.csdn.net/m0_47503416/article/details/110100690">CSDN</a>、<a href="https://www.php.cn/tool/git/490641.html">PHP中文网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改butterfly(2)-插入自定义样式</title>
      <link href="/2022/07/16/%E9%AD%94%E6%94%B9butterfly2/"/>
      <url>/2022/07/16/%E9%AD%94%E6%94%B9butterfly2/</url>
      
        <content type="html"><![CDATA[<h1 id="魔改butterfly主题2-插入自定义样式"><a href="#魔改butterfly主题2-插入自定义样式" class="headerlink" title="魔改butterfly主题2-插入自定义样式"></a>魔改butterfly主题2-插入自定义样式</h1><p><strong>在原来的butterfly主题上插入自己喜欢的样式获证更改原来的样式</strong></p><ul><li>Hexo主题给我们预备了一个自定义接口，路径在主题目录下的_config.yml里面你的Inject中，具体如下：<br><img src="/../upload/mogai2/1.png" alt="image"></li><li>我们只需要在主题目录下先建一个样式文件夹，在里面新建一个样式表（css文件）用于存放我们的自定义样式即可：<br><img src="/../upload/mogai2/2.png" alt="image"></li><li>这的Mycss里面的style.css就是我新建的样式表，随后我们在head里面的link标签中引入对应的路径即可，然后我们通过浏览器，动态捕获对应的标签类名，id名即可对对应的样式进行更改自定义：<br><img src="/../upload/mogai2/3.png" alt="image"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔改butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改butterfly(1)-魔改gallery图库</title>
      <link href="/2022/07/16/%E9%AD%94%E6%94%B9butterfly1/"/>
      <url>/2022/07/16/%E9%AD%94%E6%94%B9butterfly1/</url>
      
        <content type="html"><![CDATA[<h1 id="魔改butterfly主题1-gallery图库"><a href="#魔改butterfly主题1-gallery图库" class="headerlink" title="魔改butterfly主题1-gallery图库"></a>魔改butterfly主题1-gallery图库</h1><p><strong>将原来的gallery图库魔改成自己喜欢功能的页面跳转（这里我将gallery图库改成了一个小游戏中心）</strong></p><ul><li><h2 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h2><ul><li><p>1、首先导入gallery图库:在主题目录下的_config.yml中的menu菜单中新建导航栏小游戏<br>  <img src="/../upload/mogai1/1.png" alt="image"></p></li><li><p>2、然后调用hexo指令(hexo new page 页面名字(这里是game))新建一个页面用于存放图库,然后在这个新页面中添加小游戏的&#x2F;game&#x2F;类型用于绑定页面<br>  <img src="/../upload/mogai1/2.png" alt="image"></p></li><li><p>3、随后就是固定搭配,将代码复制进入有也页面的md文件中即可,就像上图一样,代码格式如下:</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;gallery-group-main&quot;&gt;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- 1).name：图框上面的名字 2. description：图库描述  --&gt;</span><br><span class="line">&lt;!-- 3).link：连接到对应相册的地址  --&gt;</span><br><span class="line">&lt;!-- 4).img-url：图库封面的地址 --&gt;</span><br></pre></td></tr></table></figure><p>  <strong>完成后如下图所示:</strong><br>  <img src="/../upload/mogai1/3.png" alt="image"></p></li><li><p><strong>关键步骤:</strong></p><ul><li><p>1)点击跳转的实现:这里需要魔改源代码,Hexo好像内置了插件，默认 不同源才会新的链接打开。如果想以新链接形式打开，需要改下源码，找到 【node_modules\hexo-theme-butterfly\scripts\tag\gallery.js】，代码大概在27行左右，将 &lt; a href&#x3D;’ ‘&gt;&lt;&#x2F; a&gt; 改成 &lt; a href&#x3D;’${url}’ target&#x3D;”_blank”&gt;&lt;&#x2F; a&gt; ,这样点击相册就会跳转到一个新页面。</p></li><li><p>2)解决渲染问题，要想跳转的新页面没有主题嵌入的问题（主题嵌入：跳转新页面成功了，但是还是有原来的样式，就是你博客的原样式存在，并没有我小游戏的样式存在，就相当于点击跳转新页面（回到你新的博客页面），然后游戏嵌在了博客页面里面）图如下：<br>  <img src="/../upload/mogai1/4.png" alt="image"></p></li><li><p>3)解决方法：设置指向的页面跳过渲染即可（这里是游戏页面）<br>  具体实施步骤：<br>  找到根目录下的_config.yml里面的skip_render，像下面一样跳过渲染指定的文件夹即可。<br>  <img src="/../upload/mogai1/5.png" alt="image"><br>  然后再在git bash里面一键三连，记住一定要先执行清除命令：hexo cl</p><p>  <strong>Hexo的原文档如下：</strong></p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render: &quot;mypage/**/*&quot;</span><br><span class="line"># 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &#x27;public&#x27; 目录</span><br><span class="line"># 你也可以用这种方法来跳过对指定文章文件的渲染</span><br><span class="line">skip_render: &quot;_posts/test-post.md&quot;</span><br><span class="line"># 这将会忽略对 &#x27;test-post.md&#x27; 的渲染</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="跳过主题渲染一般有两种方法："><a href="#跳过主题渲染一般有两种方法：" class="headerlink" title="跳过主题渲染一般有两种方法："></a>跳过主题渲染一般有两种方法：</h2><ul><li><strong>第一种就是上文提到的，在 config.yml 文件里（注意是Hexo本身自带的config.yml，不是主题带的config.yml）找到 skip_render: 设置跳过渲染。</strong></li><li><strong>第二种就是在你指定想要跳过渲染的页面的index.md当中，在其 Front-matter内容区域添加：</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layout: false</span><br></pre></td></tr></table></figure></li></ul><h3 id="如图所示"><a href="#如图所示" class="headerlink" title="如图所示:"></a>如图所示:</h3><p><img src="/../upload/mogai1/6.png" alt="image"><br><strong>随后去到主题目录下的config.yml 文件里在指定的标签中添加自己想要或者自定义的html文件即可,如下图所示:</strong><br><img src="/../upload/mogai1/7.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔改butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用指令</title>
      <link href="/2022/07/13/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/07/13/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo常用指令介绍"><a href="#hexo常用指令介绍" class="headerlink" title="hexo常用指令介绍"></a>hexo常用指令介绍</h1><ul><li><strong>$ hexo clean</strong> (清空)<ul><li>清除缓存文件 db.json 和已生成的静态文件 public 。</li><li>网站显示异常时可以执行这条命令试试。</li></ul></li><li><strong>$ hexo g</strong> (重新生成)<ul><li><p>生成网站静态文件到默认设置的 public 文件夹。</p></li><li><p>便于查看网站生成的静态文件或者手动部署网站；</p></li><li><p>如果使用自动部署，不需要先执行该命令；<br>  hexo g 是 hexo generate 的缩写，命令效果一致</p></li></ul></li><li><strong>$ hexo s</strong> (重新启动)<ul><li>启动本地服务器，用于预览主题。<br>   -hexo s 是 hexo server 的缩写，命令效果一致；</li><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果</li></ul></li><li><strong>$ hexo d</strong> (重新部署到仓库)<ul><li>自动生成网站静态文件，并部署到设定的仓库。</li><li>hexo d 是 hexo deploy 的缩写，命令效果一致</li></ul></li><li><strong>$ hexo new “文章标题”</strong>(新建文章)<ul><li>文章标题也可以在对应的md文件中修改</li></ul></li><li><strong>$ hexo new page 网页名</strong><ul><li>例：hexo new page welcome</li><li>新建一个标题名为welcome的页面，默认连接地址：主页地址&#x2F;welcome&#x2F;</li><li>此页面不会出现在首页文章列表和归档中，也不支持设置分类和标签</li></ul></li></ul><h2 id="更新博客"><a href="#更新博客" class="headerlink" title="更新博客"></a>更新博客</h2><ul><li>一般会打开博客所在文件夹内右键 Git Bash Here，然后再命令行一键三连： <figure class="highlight plaintext"><figcaption><span>Command(代码指令)</span></figcaption><table><tr><td class="code"><pre><span class="line">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li><li>然后我么就可以打开浏览器输入主机地址:localhost:4000&#x2F;，查看自己更新的博客了！</li><li>不过这只是在本地进行了更新，要想部署到网上（Github上），还要输入如下指令： <figure class="highlight plaintext"><figcaption><span>Command(代码指令)</span></figcaption><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li><li>这样就能自动生成网站静态文件，并部署到我们设定的github仓库上了,别人访问我们的网站也能看到我们更新的内容了。</li></ul><blockquote><p>这篇博客引用了作者为”<strong>到现在负</strong>“的文章<br>原文链接为:<a href="https://blog.csdn.net/dxxzst/article/details/76135935">CSDN</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello！欢迎来到我的仓库！</title>
      <link href="/2022/07/13/Hello-Blog/"/>
      <url>/2022/07/13/Hello-Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-欢迎来到我的博客"><a href="#Hello-欢迎来到我的博客" class="headerlink" title="Hello!欢迎来到我的博客!"></a>Hello!欢迎来到我的博客!</h1><h3 id="这是我的第一篇博客，用来记录这个博客网站的诞生！"><a href="#这是我的第一篇博客，用来记录这个博客网站的诞生！" class="headerlink" title="这是我的第一篇博客，用来记录这个博客网站的诞生！"></a>这是我的第一篇博客，用来记录这个博客网站的诞生！</h3><h3 id="后续我将会在这个博客中记录自己的前端学习历程！"><a href="#后续我将会在这个博客中记录自己的前端学习历程！" class="headerlink" title="后续我将会在这个博客中记录自己的前端学习历程！"></a>后续我将会在这个博客中记录自己的前端学习历程！</h3><ul><li><ul><li><ul><li><ul><li><strong>该博客站点诞生于2022年7月13日</strong></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博主个人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
